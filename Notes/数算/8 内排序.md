
# 基本概念

- 内部排序 internal sorting ：要排序的东西少，内存放得下，那排序过程就直接在内存进行
- 外部排序 external sorting ：要排序的东西多，内存放不下，排序过程中还需要访问外存

记录 Record ： 进行排序的基本单位
关键码 Key ： 唯一确定记录的一个或多个域
排序码 Sort Key ： 作为排序运算依据的一个或多个域
序列 Sequence ： 线性表，由记录组成的集合
排序 Sorting ：将序列中的记录按照排序码特定的顺序排列起来

>比如对于一个学生的信息 `{学号:101, 姓名:"张三", 年龄:20}` ，这玩意就是一个记录；关键码是唯一标识学生信息的东西，比如说学号；排序码规定按照什么标准排序，比如说年龄，也可以是先看年龄、再看姓名

**稳定性**：有两个记录的排序码相等，在排序前后，它们的先后顺序保持不变

排序算法的衡量标准
- 时间代价：主要看记录的**比较和交换**次数，分为最小/最大/平均时间代价 
- 空间代价：所需附加空间的大小

# 简单排序

## 插入排序

### 直接插入排序

维护一个已排序集合，依次把序列中的元素加进去，每次遍历这个已排序集合，找到应该插入的位置（逐渐与前面的元素交换，直到碰上比它大/小的元素）

```cpp
// 从小到达排序
void StraightInsertSorter(Record Array[], int n){
    for (int i=1; i<n; i++) {
        for (int j=i; j>0; j--){
            if (Array[j] < Array[j-1]) // 比前面的小
                swap(Array, j, j-1); // 就换到前面去
            else break; // 如果前面的更小，就不用再换了
        }
    }
}
```

- 这个算法是稳定的
- 空间代价 $\Theta(1)$ ，因为交换操作需要一个辅助空间
- 时间代价最佳 $\Theta(n)$ ，最差和平均是 $\Theta(n^2)$ 
- 实验表明，当 n 较小时，直接插入排序是一种高效的排序算法

### 优化的插入排序

上面的算法是逐个交换去实现“插入”的效果，需要多次借助临时变量，会有很多次赋值操作，考虑真实的进行“插入”，即找到一个元素应该放到的位置，后面的元素依次往后窜

```cpp
Void ImprovedInsertSorter (Record Array[], int n) {
    Record TempRecord;
    for (int i=1; i<n; i++) {
        TempRecord=Array[i];
        int j=i-1;
        while ((j>=0) && (TempRecord < Array[j])) {
            Array[j+1] = Array[j];
            j--;
        }
        Array[j+1] = TempRecord;
    }
}
```

但是这个算法只是减少了赋值次数，并没有影响时间复杂度的量级

### 基于二分查找的插入排序

前面的算法是通过遍历找到插入位置，但实际上可以利用二分查找来确定

![[数算/img/img8/image.png]]

>因为要使用 `left` 作为插入位置，所以终止条件是 `left < right`

```cpp
void BinaryInsertSorter (Record Array[], int n) {
    Record TempRecord;    int left, right, middle;
    for (int i=1; i<n; i++) {
        TempRecord = Array[i];
        left = 0; right = i-1;
        // 查找
        while(left <= right) {
            middle = (left+right)/2;
            if (TempRecord < Array[middle])
                right = middle-1;
            else 
	            left = middle+1;
        }
        // 插入
        for(int j = i-1; j >= left; j --)
            Array[j+1] = Array[j];
        Array[left] = TempRecord;
    }
}
```

二分查找只是把查找时进行的比较的次数降低到 $n\log n$ ，插入时的移动次数没有变，所以最差和平均仍然是 $\Theta(n^2)$ ，但是最好情况变为 $\Theta(n\log n)$ ，因为即便插入位置在末端，二分查找也得从中间开始
## 冒泡排序

### 基本的冒泡排序

假设要从小到大排序，我们从后往前遍历，依次比较相邻元素，逆序则交换，这样走一趟后，最小的元素就会像泡泡一样浮到最前端，而后对于剩下的部分进行同样的操作

![[数算/img/img8/image-1.png]]

当然也可以从前往后遍历，这样就是最大的放到了最后面

空间代价 $\Theta(1)$ ，最好、最差、平均时间代价均为 $\Theta(n^2)$

### 优化的冒泡排序

考虑检查每次冒泡过程中是否发生过交换，如果没有，说明已经排好序了，就可以提前终止，这样最好时间代价变为 $\Theta(n)$ 

## 直接选择排序

假设要从小到大排序，我们从序列中选出最小的元素放到第一个位置（与第一个位置的元素交换），再从剩下的部分选出最小的放到第二个位置，以此类推

![[数算/img/img8/image-2.png]]

## 时间复杂度对比

![[数算/img/img8/image-3.png]]

# Shell 排序/缩小增量排序

Shell 排序基于插入排序的两个性质
- 在序列较短的情形下效率高 
- 在整体有序的的情形下时间代价低

所以我们考虑先把一个较长的序列分割为很多较短的序列分别排序，这样以来整个序列就会变得更有序一些，可以适当扩大分割的序列的规模，直到最后对整个序列进行一次插入排序，过程如下
- 选定一系列间隔增量  $n > d_1 > d_2 > \cdots > d_t = 1$ ， Shell 最初提出的是 $d_1 = \lfloor n / 2\rfloor,  d_{i+1} = \lfloor d_i / 2\rfloor$
- 将序列按 $d_1$ 分组（相距 $d_1$ 的元素放到一组），在各组内采用直接插入法进行排序
- 分别按 $d_2, \cdots d_t$ 重复上述分组和排序工作

![[数算/img/img8/image-4.png]]

```cpp
Void ShellSorter (Record Array[], int n){
    for (int delta=n/2; delta>0; delta/=2)
	    // 分别对每个子序列排序 
        for (int j=0; j<delta; j++)
            ModifiedInsertSort(&Array[j], n-j, delta);
}

ModifiedInsertSort(Record Array[],int n, int delta) {
    for (int i=delta; i<n; i+=delta)
        for (int j=i; j>=delta; j-=delta){
            if (Array[j] < Array[j-delta])
                swap(Array, j, j-delta);
            else break;
        }
}
```

- 使用 Hibbard 增量序列 $\{2^k - 1,\ 2^{k-1} - 1,\ \dots,\ 7,\ 3,\ 1\}$ 的 Shell 排序的效率，在最坏情况下可以达到 $O(n^{3/2})$ 
- Shell 排序算法的时间代价分析比较复杂，平均情况下，其比较和移动次数都为 $n^{1.3}$ 左右
- 仅交换时需要辅助空间，空间代价为$O(1)$ 
- Shell 排序是不稳定的

# 分治排序

分而治之：将问题分为若干个差不多的子问题 ，它们可以用同一套方法处理，对于排序就是将序列划分为一堆子序列，分别进行排序，最后整合起来

## 快速排序

考虑将一个序列每次二分为两个子序列，要从小到大排序，我们可以选取一个参考点（轴值），然后重新排布这个序列，使得左边的元素都比它小（小于等于），右边的元素都比它大，这样只需对左右两侧的序列分别排序就行，而后递归的划分下去

![[数算/img/img8/image-5.png]]

```cpp
void QuickSort(Record Array[], int left, int right) {
    if (left < right) {
	    // 选择轴值并分割
        int pivot = SelectPivot(left, right);
        pivot = Partition(Array, left, right);
        // 对左右子序列递归
        QuickSort(Array, left, pivot - 1);
        QuickSort(Array, pivot + 1, right);
    }
}
```

在选择轴值时，需要保证左右两侧的序列长度尽可能相同，我们先假设直接选取第一个元素作为轴值，然后需要重新排布这个序列，保证比它小的都放到左边，大的都放到右边，并确定轴值的最终位置

![[数算/img/img8/image-7.png]]

```cpp
int Partition(Record Array[], int left, int right) {
    int i = left, j = right;
    Record pivotValue = Array[left]; // 选取首元素作为轴值
    while (i != j) {
	    // 从右往左找到第一个小于等于轴值的元素
        while ((Array[j] > pivotValue) && (i < j)) j--;
        // 放到左边，左指针往右窜
        if (i < j) { Array[i] = Array[j]; i++; }
        // 从左往右找到第一个大于轴值的元素
        while ((Array[i] <= pivotValue) && (i < j)) i++;
        // 放到右边，右指针往左窜
        if (i < j) { Array[j] = Array[i]; j--; }
    }
    // 最终i=j即为轴值位置
    Array[i] = pivotValue;
    return i;
}
```

![[数算/img/img8/image-6.png]]

- 最好情况两个子序列长度差不多，时间代价 $O(n\log n)$ ，空间代价 $O(\log n)$ （虽然是原地操作，但是递归调用栈需要空间）
- 最差情况左/右子序列没有元素，时间代价 $O(n^2)$ ，空间代价 $O(n)$ ；平均情况时间代价 $O(n\log n)$ ，空间代价 $O(\log n)$ ，证明如下

我们先选择轴值并重排序列，由于左右指针没有回退，时间代价为 $O(n)$ ，即 $t=cn$ ，然后进行递归，考虑所有可能的左右子序列分割情况，可得

$$
T(n) = \frac{1}{n} \sum_{i=0}^{n-1} (T(i) + T(n-i-1)) + cn = \frac{2}{n} \sum_{i=0}^{n-1} T(i) + cn
$$

两侧同乘 $n$ 得

$$
nT(n) = 2 \sum_{i=0}^{n-1} T(i) + cn^2
$$

将 $n$ 换为 $n-1$ ，然后两式做差得

$$
nT(n) - (n-1)T(n-1) = 2T(n-1) + 2cn - c
$$

可以整理为以下递推式

$$
\frac{T(n)}{n+1} = \frac{T(n-1)}{n} + \frac{2c}{n+1}
$$

又已知 $1+\frac{1}{2}+\cdots+\frac{1}{n}\sim \log n$ ，故 $T(n)\sim n\log n$ 

## 归并排序

我们直接将原始序列划分为两个子序列，分别对每个子序列递归划分 ，直至不可划分为止，最后将排好序的子序列合并为一个有序序列（归并过程）

>可见快速排序侧重于在分割时进行调整，而归并排序侧重于在归并时进行调整

![[数算/img/img8/image-8.png]]

而归并两个有序序列很简单，只需要依次比较头部元素的大小，把小的/大的拿出来就行

```cpp
void MergeSort(Record Array[], Record TempArray[], int left, int right) {
    int middle = (left + right) / 2;
    if (left < right) { // 如果left>=right说明只有0/1个元素，不用排序
        MergeSort(Array, TempArray, left, middle);
        MergeSort(Array, TempArray, middle+1, right);
        Merge(Array, TempArray, left, right, middle);
    }
}
```

```cpp
void Merge(Record Array[], Record TempArray[], int left, int right, int middle) { // 左右子序列为[l,m]和[m+1,r]
    int i, j, index1, index2;
    // 先把左右子序列拷贝到临时数组，因为需要把结果写入到原数组
    for (j = left; j <= right; j++)
        TempArray[j] = Array[j];
    index1 = left; // 左子序列头部
    index2 = middle+1; // 右子序列头部
    i = left; // 写入位置
    while (index1 <= middle && index2 <= right) {
	    // 把小的拿出来，写入原数组，相等时先拿左边的，保证稳定性
        if (TempArray[index1] <= TempArray[index2])
            Array[i++] = TempArray[index1++];
        else 
            Array[i++] = TempArray[index2++];
    }
	
	// 把剩下的全拿出来
    while (index1 <= middle)
        Array[i++] = TempArray[index1++];
    while (index2 <= right)
        Array[i++] = TempArray[index2++];
}
```

- 每次归并 $O(n)$ ，共进行 $\lceil \log n \rceil$ 次，时间代价为 $O(n\log n)$ 
- 需要临时数组，空间代价为 $O(n)$ ，这导致其是辅助存储量最多的一种排序
- 是稳定的，因为归并时我们指定了头部元素相等时先拿左边的

# 堆排序

根据序列建立一个最大/最小堆，每次取出堆顶元素放到相应位置
- 建堆 $O(n)$ ，取堆顶 $O(\log n)$ ，进行 $n$ 次，总时间代价为 $O(n\log n)$ （理论上最佳、最差、平均情况都是这样的）
- 空间代价 $O(1)$ ，因为可以进行原地建堆，由于堆是完全二叉树，直接用一个数组就可以表示，那我们就只用在原来的数组内部进行操作就可以建堆
- 是不稳定的

>注意分析比较次数时，每次交换元素进行 2 次比较（与两个子节点比较），而且需要考虑建堆时的比较次数（$2n$）

# 分配排序

前面的排序都是在原序列上进行比较和交换操作，而分配排序是基于“分配”和“收集”操作的
- 分配（散射）：遍历待排序序列，根据元素的值，将元素放入对应的“桶”中
    - “桶”可以是一个队列、链表或一个简单的统计数组
    - 这个分配过程是直接定位的，时间复杂度可以达到 $O(1)$
- 收集（聚合）：按照一定的顺序，依次将每个桶中的元素放到正确的位置，形成新的序列

这种方法往往需要预先知道序列的一些信息，比如元素的取值范围

## 桶排序

假设元素取值范围为 $[0,m)$ ，我们可以搞 $m$ 个桶，用来统计取值为 $i$ 的元素有多少个，这样就很容易构建出排好序的序列

这里我们在使用 count 数组进行统计后，进一步计算后继起始下标，此时 `count[i]` 代表元素 $i+1$ 在排好序的序列中应该从哪开始放

![[数算/img/img8/image-9.png]]

在计算出后继起始下标后，我们进行收集，遍历原序列中的元素，根据这个数组确定其正确的位置，以 `count[8]=8` 为例，代表 9 是从下标 8 的位置开始放的，假设遍历原序列时碰到了 "8" ，就先给 `count[8]--` ，此时 `count[8]=7` ，代表最后一个 8 在下标 7 的位置，把碰到的 "8" 放到这个位置；后续碰到另一个 "8" 时，也先 `count[8]--` 变为 6 ，就放到下标 6 的位置

在收集时，先遍历到的元素被放到了后面，为了保证稳定，我们从后往前收集

```cpp
void BucketSort(Record Array[], int n, int m) {
    int* TempArray = new Record[n];
    int* count = new int[m];
    int i;
	// 把序列复制到临时数组
    for (i = 0; i < n; i++)
        TempArray[i] = Array[i];
	// 初始化统计数组
    for (i = 0; i < m; i++)
        count[i] = 0;
	// 统计每个值出现的次数
    for (i = 0; i < n; i++)
        count[Array[i]]++;
	// 计算后继起始下标
    for (i = 1; i < m; i++)
        count[i] = count[i - 1] + count[i];
    // 把元素放到正确的位置
    for (i = n - 1; i >= 0; i--) {
	    count[TempArray[i]]--;
        Array[count[TempArray[i]]] = TempArray[i];
    }
}
```

- 计算后继起始下标用时 $m$ ，分配和收集用时 $n$ ，总时间代价 $O(m+n)$
- 需要一个计数器和临时数组，空间代价 $O(m+n)$ 
- 是稳定的
- 适用于 $m<<n$ 的情况

## 基数排序

对于一个 $d$ 位的排序码 $K=(k_{d-1},k_{d-2},…,k_1,k_0)$ ，**基数**就是排序码中的每一位元素 $k_i$ 的取值范围，记作 $r$ ，这决定了需要用多少个桶去统计

>其中 $k_{d-1}$ 称为最高排序码，$k_0$ 称为最低排序码，代表排序的优先级

比如对于一个扑克牌，按照排序码（花色，面值）来排序，那花色对应的基数就是 4 ，面值对应的基数是 13 ；甚至可以把一个多位数拆开看，比如一个四位数拆成排序码 （千位，百位，十位，个位），它们的基数都是 10 ，这就解决了前面的 $m<<n$ 的问题

**高位优先法 MSD** ：按照排序码从前到后的顺序排序（只是处理的先后顺序，不是优先级）
- 先按 $k_{d-1}$ 把元素分配到一堆桶里，对于每个桶内的元素，再按 $k_{d-2}$ 分配到一堆小桶中，以此类推
- 最后把所有桶的元素收集起来
- 这是一个“分 分 ... 收”的过程，是一个递归分治问题

**低位优先法 LSD** ：按照排序码从后到前的顺序排序
- 先按 $k_0$ 进行一次桶排序，再按 $k_1$ 进行一次桶排序，以此类推
- 这是一个“分收 分收 ... 分收” 的过程，比较简单，计算机常用

下面以 LSD 为例，讨论基数排序的实现方式

### 基于顺序存储的基数排序

![[数算/img/img8/image-10.png]]

![[数算/img/img8/image-11.png]]

- 需要分配和收集，时间代价 $O(d(n+r))$ 
- 需要临时数组和 count 数组，空间代价 $O(n+r)$ 

### 基于静态链的基数排序

桶不再是一个简单的计数数组，而是一个链表，往里边放元素

![[数算/img/img8/image-12.png]]

![[数算/img/img8/image-13.png]]

![[数算/img/img8/image-14.png]]

- 需为每个桶声明一个 head 和 tail 指针，为序列中的每一个元素声明一个 next 指针即可，空间代价 $O(n+r)$ 
- 由于不需要实际移动元素，只需修改指针，时间代价 $O(d(n+r))$ 

>使用 $d$ 位关键码，每一位的基数都是 $r$ ，假设序列中 $n$ 个元素都不同（最坏情况），那最多能表示 $r^d$ 个元素，则能够处理的序列长度为 $n\leq r^d$ ，即 $d\geq \log_r n$ ，这就变成了 $O(n\log n)$

# 索引排序

当记录的规模很大时，直接移动开销会很大，考虑利用一个索引代表一个记录，这样只需要对索引进行排序，并根据索引查找记录，这个过程记录本身不移动，如有需要，最后根据这个排好序的索引序列调整记录的实际位置即可（记录的物理调整）

但是在物理调整时，由于记录规模很大，我们不能像之前那样先把原序列拷贝到临时数组，而是进行原地调整，假设有如下的数组 `A` ，得到了其排好序的索引序列 `idx` ，需要调整元素的位置

![[数算/img/img8/image-17.png]]

遍历 `idx` ，从下标 0 开始，发现下标 0 的位置应该放 `A` 中下标 5 的元素，搞个临时变量 `tmp` 把 `A` 中下标 0 的元素先存起来，把下标 5 的元素拷贝过来，而后更新 `idx[0]=0` 代表这个元素已经放到了正确的位置

再看 `idx` 下标 5 处，应该放 `A` 中下标 4 的元素，由于我们已经把下标 5 处的元素放到了正确的位置，所以可以直接把下标 4 处的元素拷贝过来，同样更新 `idx[5]=5` 

而后看 `idx` 下标 4 处，同理，把下标 2 的元素拷贝过来，更新 `idx[4]=4` ；而后看 `idx` 下标 2 处，发现应该放下标 0 处的元素，而这正好是一开始的位置，这个元素一开始被存在了 `tmp` 里，所以把 `tmp` 的元素拷贝过来，更新 `idx[2]=2` ，这就走了一圈，形成了一个拷贝环

之后往下遍历，到了下标 1 处，重复同样的过程，后续也同理，可以发现整个过程中，一共形成了下面 3 个拷贝环
- 29-12-34-34 ：length 4
- 25 ： length 1
- 64-32-45 ： length 3
- 每个拷贝环进行的拷贝操作数为 length+1 次

```cpp
void AdjustRecord(Record Array[], int IndexArray[], int n) {
    Record TempRec;
    int i, j;
    for (i = 0; i < n; i++) {
        j = i;
        TempRec = Array[i]; // 存储开头的元素
        while (IndexArray[j] != i) {
            int k = IndexArray[j]; // 应该放下标k的元素
            Array[j] = Array[k]; // 拷贝过来
            IndexArray[j] = j; // 更新索引数组
            j = k; // 往下移动
        }
        // 此时i=j，回到了开头，把tmp的元素拷贝过来
        Array[j] = TempRec;
        IndexArray[j] = j;
    }
}
```

- 物理调整的时间代价为 $O(n)$ ，空间代价为 $O(1)$ 

# 时间空间代价与稳定性总结

![[数算/img/img8/image-15.png]]

# 排序问题的界

upper bound 上界：现有的算法所能达到的最佳效率
lower bound 下界：理论上解决该问题所需的最低成本

排序问题的下限应该在 $O(n)$ 到 $O(n\log n)$ 之间
- 任何排序算法都至少要查看一次每个元素，否则根本不知道把它放在哪里，所以不可能优于 $O(n)$ 
- 可以证明，基于比较的排序算法最优为 $O(n\log n)$ ，其它算法可能比这个快

用判定树模拟基于比较的排序
- 每个内部节点 代表一次比较操作
- 每个分支代表比较的结果
- 每个叶子节点代表一个可能的排序结果

![[数算/img/img8/image-16.png]]

判定树叶子节点的最大深度是排序算法在最差情况下需要的比较次数，叶子节点的最小深度就是最佳情况下的比较次数

对于 $n$ 个记录，共有 $n!$ 个叶结点，则判定树的深度为 $\log(n!)$ ，最差情况下需要 $\log(n!)$ 次比较，即 $\Omega(n \cdot \log n)$ ，代表最差情况下任何基于比较的排序算法最好的也仍然需要 $\Omega(n \log n)$ 次比较




