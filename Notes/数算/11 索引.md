
# 基本概念

主码：从关键码中选出的一个“官方”标识，只能有一个主码，它必须唯一且不能为空
辅码：不是用来唯一标识记录，但为了提高查询速度而特意采用的，多数检索都是利用辅码索引完成的

>比如学生信息表中，学号和身份证都是关键码，可以选择学号作为主码；但是你直接喊学号别人不一定反应得过来，可以选择姓名作为辅码（但是可能有重名情况）

索引：把关键码与对应记录的位置关联起来，可以表示为（关键码，地址）对
索引文件：用于记录索引关系的文件
- 主文件：原始记录所在的文件
- 一个主文件可能对应多个索引文件，每个索引文件对应一个索引字段
- 不需要重新排列主文件中的记录
索引技术：支持高效检索，动态的数据插入、删除、更新

稠密索引：给每个记录都搞一个索引，主文件不需要按关键码次序排列，咋排列每个记录都找得着
稀疏索引：将记录分组/分块，给每一块的起始位置搞一个索引，那记录就需要按关键码次序存放，以便确定要查找的记录在哪一组里

![[数算/img/img11/image.png]]

# 静态索引

数据集合相对固定，索引构建后很少更新，更新时需要重建全部或大部分索引

## 线性索引

索引文件中，索引项按照索引码值的顺序进行排列，比如

```
[101 -> 地址x]
[102 -> 地址y]
[103 -> 地址z]
[104 -> 地址a]
[105 -> 地址b]
...
```

这样就能支持二分查找，但是仍需要频繁的访问外存

---

可以在一级索引的基础上再搞一个二级索引，将一级索引分块，记录每块的起始键和地址

![[数算/img/img11/image-1.png]]

先根据二级索引找到记录所在块，再从这个块里用二分查找

## 倒排索引

把属性值作为索引，索引表中包含一个属性值和具有该属性值的各关键码或者记录地址；这个索引表称为倒排表，带有倒排索引的文件称为倒排文件

>比如一个员工表，关键码是员工 ID ，但是可以把部门当作索引，记下每个部门有哪些员工 / 每个部门的所有员工的 ID 

优点：支持基于属性的高效检索
缺点：保存倒排表需要较大开销（因为可能有很多属性），降低了更新运算的效率（因为要根据具体的属性值去调整）

---

正文：文档的核心文字内容（去掉页眉页脚等），就是一段纯文字
正文索引：支持对文本内容的快速检索（有一堆文本文档，要找出一个词在哪里出现了）
- 词索引：将文本分成一堆词 / 提取出关键词，把这些词作为索引，记下它们出现的位置（在哪些文档出现、具体在文档中的哪个位置），对于中文需要采用特殊的“分词”方法
- 全文索引：正文看作一个长的字符串 ，把每个子串出现的位置都记下来，这样检索内容就不局限于某个词，但是开销很大

# 动态索引

支持频繁的插入、删除、更新操作，通过局部调整维护索引结构

## B 树

在之前的树中，比如二叉树，每个节点都只对应一个记录，但是 B 树中一个节点里面可以有多个记录，存储着它们的（关键码，地址）对

>B 树也叫 B-树，但这个 “-” 是“杠”而非“减”

B 树的根节点和子节点存在以下关系
- 设根节点存的数（关键码）是 $K_1,\cdots,K_n(K_1<\cdots<K_n)$ ，那这个根节点就有 $n+1$ 个子节点
- 这 $n$ 个数把数轴划分成 $n+1$ 个区间，第 $i$ 个子节点存的数就处在第 $i$ 个区间中

![[数算/img/img11/image-2.png]]

>注意不存在 $K_i=K_j$ 的情况，因为关键码是唯一的；上图只是个示意，实际上完全可以搞两个表，分别存 $K$ 和 $p$

比如下面的 B 树（省略了每个关键码对应的地址），如果要找 70 
- 首先看根节点 A ，里面没有
- 那就要看 70 处在哪个区间，发现 70>50 ，说明处在第 3 个区间
- 就从第 3 个子节点 D 里找（以此类推）

```
.           A [25,50]
.       /       |       \
. B [10,20] C [30,40] D [60,70]
```

B 树中一个节点的最大分支数称为阶数，一个 $m$ 阶 B 树还要满足以下性质，以保证树看起来比较平衡
- 上界：每个节点最多有 $m$ 个子节点（每个节点最多存 $m-1$ 个数）
- 下界：根节点至少有 1 个数，其它非叶节点至少有 $\lceil m/2 \rceil-1$ 个数
- 叶节点都位于同一层，且存着 $\lceil m/2 \rceil-1 \sim m-1$ 个关键码

为了提高访问效率，一个节点中的关键码可以存到一个磁盘页里

对于一个高度为 $h$ 的 B 树，查找时最多需要 $h+1$ 次访问外存（$h$ 次找到关键码，还需要 1 次根据关键码对应的地址访问记录）

### 插入

插入过程如下
- 先放到最底层的一个节点（根据所在区间判断要放到哪个叶节点，可以进行一次查找来判断）
- 如果节点存储的关键码个数溢出，则进行分裂，把中间的关键码放到父节点
- 如果父节点也溢出，继续分裂；如果根节点也溢出，就向上增加一层


设节点 $A$ 中已有 $m-1$ 个关键码，当再插入一个关键码后节点的存储状态为

$$(m\vert p_0, K_1, p_1, K_2, p_2, \ldots, K_m, p_m)$$

- $K_i < K_{i+1}, 1 \leq i < m$
- 最前面的数字 $m$ 表示节点存了 $m$ 个关键码
- $p_i$ 是指向 $A$ 的第 $i$ 个子节点的指针

从中间劈开后，分裂出的两个节点如下，其中 $q$ 是新增的一个节点

$$
\begin{align}
&A'=(\lceil m/2 \rceil -1\vert p_0, K_1, p_1, \ldots, K_{\lceil m/2 \rceil -1}, p_{\lceil m/2 \rceil -1})\\
&q=(m - \lceil m/2 \rceil\vert p_{\lceil m/2 \rceil}, K_{\lceil m/2 \rceil +1}, p_{\lceil m/2 \rceil +1}, \ldots, K_m, p_m)
\end{align}
$$

位于中间的关键码 $K_{\lceil m/2 \rceil}$ 与指向新节点 $q$ 的指针形成一个二元组 $(K_{\lceil m/2 \rceil}, q)$，插入到 $A$ 的父节点中

比如在这个 3 阶 B 树中插入 80 ， 发现应该放到 D 中，但是 3 阶 B 树每个节点最多只能存 2 个数，放入后溢出

```
.           A [25,50]
.       /       |       \
. B [10,20] C [30,40] D [60,70,80] <--溢出
```

将 D 从中间劈开，分裂为 2 个节点，把中间值 70 （以及新分裂出的节点 E 的指针）放到父节点 A ，发现还是溢出，继续分裂

```
.             A [25,50,70] <--溢出
.       /       /      \      \
. B [10,20] C [30,40] D [60] E [80]
```

由于分裂时自动把指针也分开了，所以 A 分裂后的节点与其子节点的连接关系会自动分好，可得最终结果为

```
.               R [50]
.           /            \
.        A1 [25]        A2 [70]
.       /       \      /      \
. B [10,20] C [30,40] D [60] E [80]
```

在分析访问外存次数时，我们默认查找时读取的节点已经都在内存中了，那向上分裂时就不用再访问外存了
- 读取外存次数：与一开始查找相同
- 最少写入外存次数：1 次（没有分裂），若考虑对关键码对应记录的访问，则再加 1 次

### 删除

删除时，如果删除的是内部节点中的数
- 找到它的后继（第一个比这个数大的数）：设删的数是这个节点存的第 $i$ 个数，那就从第 $i+1$ 个子节点对应的子树中找，找到其中最小的那个数（子树中最左下角的数）
- 与后继交换，然后删除这个数

>由于后继是第一个比删除数大的数，所以交换并删除后，子节点的数仍然是按照父节点分出的区间排列的；由于后继一定在叶节点，所以交换后，问题就变成了如何删除叶节点中的一个数

比如说下面的 5 阶 B 树，要找到 A 中的 103 的后继，它是 A 的第 1 个数，就从第 2 个子节点 C 对应的子树找，最左下角的是最底层的最左叶节点的第一个数，就是 G 中的 108 

```
.                        A [103]
.               /                         \
.       B [25,50]                       C [120,150]
.     /     |       \            /              |       \
.   D       E        F          G               H        I
. [11,15] [35,43] [81,95] [108,110,115,118] [134,146] [156,177]
```

现在要删除 C 中的 120 ，后继是 134 ，就与之交换

```
.                        A [103]
.               /                         \
.       B [25,50]                       C [134,150]
.     /     |       \            /              |       \
.   D       E        F          G               H        I
. [11,15] [35,43] [81,95] [108,110,115,118] [120,146] [156,177]
.                                             ^
.                                           delete
```

---

现在要删除交换后的 120 ，即删除叶节点中的一个数，这可能导致删除后，这个节点存的数太少了（小于 $\lceil m/2 \rceil-1$ 个，如果没有下溢那直接删了就行）

由于这个树是 5 阶的，所以 $\lceil m/2 \rceil-1=2$ ，但是删除 120 后 H 中只有 1 个数了，发生下溢，需要从别的节点“借数”来保证数量足够

```
.                        A [103]
.               /                         \
.       B [25,50]                       C [134,150]
.     /     |       \            /              |       \
.   D       E        F          G               H        I
. [11,15] [35,43] [81,95] [108,110,115,118]   [146]  [156,177]
```

先考虑从相邻的兄弟节点借，需要保证兄弟节点的数借过来后，这个兄弟不会下溢，假设我们优先考虑左侧的兄弟 G ，它有 4 个数，借一个还剩 3 个，完全够用（而右边的 I 借完了会下溢）

由于我们需要保证借完了仍满足子节点的数按照父节点分出的区间排列的，所以这个借的过程实际上是 G 给父节点 C 一个数，C 给 H 一个数，相当于把区间边界窜了一下

现在是从左边的子节点借，那就取 G 中最大的数 118 给到 C ；在 C 中取出 G 和 H 的分界，即 134 ，这可以用以下方法找到：删除数所在的 H 是 C 的第 2 个子节点，那就把 C 中第 1 个数（$i-1$） 134 拿下来（如果从右边借，那就是取右兄弟最小、取父节点第 $i$ 个数）

```
.                        A [103]
.               /                         \
.       B [25,50]                       C [118,150]
.     /     |       \            /            |         \
.   D       E        F          G             H          I
. [11,15] [35,43] [81,95] [108,110,115]   [134,146]  [156,177]
```

---

但是如果两个相邻的兄弟节点的数都不够借，只能从父节点借，但是这会导致父节点的数少了一个，那子节点也得少一个，所以得合并两个子节点（假设优先与左侧兄弟合并）；由于仍需要保证子节点按区间分布，所以需要把合并的两个节点的分界值借下来

比如说再删除 150 ，与后继 156 交换并删除

```
.                        A [103]
.               /                         \
.       B [25,50]                       C [118,156]
.     /     |       \            /            |         \
.   D       E        F          G             H          I
. [11,15] [35,43] [81,95] [108,110,115]   [134,146]  [150,177]
.                                                      ^
.                                                    delete
```

但是兄弟 H 只有 2 个数，没法借，只能从 C 借，然后把 H 和 I 合并，那我们就得借 H 和 I 的分界，即 156 

```
.                        A [103]
.               /                     \
.       B [25,50]                    C [118]
.     /     |       \            /            \
.   D       E        F          G             HI
. [11,15] [35,43] [81,95] [108,110,115]   [134,146,156,177]
```

但是现在 C 又下溢了，兄弟 B 也不够借，只能把 A 中的 103 借过来，这会把根节点搞得没数了，那就只能让 BC 合并后来做根节点

```
.              BC [25,50,103,118]
.     /     /        |         \             \
.   D       E        F          G             HI
. [11,15] [35,43] [81,95] [108,110,115]   [134,146,156,177]
```

---

总结一下
- 将删除的数与后继换位，把这个数搞到叶节点
- 如果这个叶节点相邻兄弟能借，就借一个（兄弟给父节点一个，父节点给叶节点一个）
- 如果兄弟都不能借，就从父节点借，然后合并左 / 右兄弟；如果借完了父节点下溢，就向上递归

### 性能分析

我们先证明一个引理：设共有 $N$ 个关键码，则 B 树空指针数量为 $N+1$ 

这里空指针是指：假设我们认为叶节点也像内部节点那样存着一堆指针，只不过这些指针是空指针（即假设叶节点连着一堆空的子节点）

设空指针数为 $l$ ，节点数为 $n$ ，关键码个数为 $N$，考虑边的总数，一部分是 B 树本身的边，共 $n-1$ 个（除了根节点，每个节点脑袋上都连着一个边）；另一部分是叶节点连接空节点的边，共 $l$ 个，则总边数为

$$l + n - 1$$

假设 $n$ 个节点关键码个数分别为 $x_1,\cdots,x_n$ ，由于每个节点的射出的边数比关键码个数多 1 ，则总的边数为

$$(x_1 + 1) + (x_2 + 1) + ... + (x_n + 1)$$

而 $x_1+\cdots+x_n=N$ ，故总边数为 $N+n$ ，综合这两种求边数的方式可得

$$l + n - 1 = N + n$$

则 $l=N+1$ ，即有 $N+1$ 个空指针

---

由于根节点至少 1 个数，其余内部节点至少 $\lceil m / 2 \rceil-1$ 个数，即根节点至少有 2 个子节点，其余内部节点至少有 $\lceil m / 2 \rceil$ 个子节点，则各层节点数至少为
- 第 0 层根至少 1 个节点，第 1 层至少 2 个节点  
- 第 $i$ 层至少 $2 \cdot \lceil m / 2 \rceil^{i-1}$ 个节点（$i\geq1$）

由引理可得共有 $N+1$ 个空指针，而每个空指针指向一个空节点，那么共有 $N+1$ 个空节点；设这个 B 树高度为 $k$ （从 1 开始算），则叶节点层数为 $k-1$ （从 0 开始算），那空节点就在第 $k$ 层，而第 $i$ 层至少 $2 \cdot \lceil m / 2 \rceil^{i-1}$ 个节点，可得下面的不等式

$$N + 1 \geq 2 \cdot \lceil m / 2 \rceil^{k-1}$$

即

$$k \leq 1 + \log_{\lceil m / 2 \rceil} \left(\frac{N + 1}{2}\right)$$

值得注意的是，$k$ 正好对应着查找时的最大读盘次数（这里我们默认每个节点的数据都存到一个页块里，一次读盘就能把这个页块全读到内存，那么每到一个节点，就需要一次读盘，后续确定具体区间只需在内存进行），也就意味着你可以根据关键码数与阶数，计算查找时至多要多少次读盘

---

考虑从零开始，通过逐渐插入来构建一个 B 树，这个过程中的最大分裂次数，设关键码数量为 $N$ ，最终 B 树的节点数为 $p$ ，由于根节点至少 1 个数，其余节点至少 $\lceil m/2 \rceil - 1$ 个数，则

$$N \geq 1 + (\lceil m/2 \rceil - 1)(p-1)$$

最差情况下，每个节点都是分裂出来的，那么总分裂次数就是 $p-1$ ，则

$$p-1 \leq \frac{N-1}{\lceil m/2 \rceil - 1}$$

可得​每次插入关键码时的平均分裂次数满足

$$s = \frac{p - 1}{N} \leq \frac{N - 1}{(\lceil m / 2 \rceil - 1) \cdot N} \leq \frac{1}{\lceil m / 2 \rceil - 1}$$

## B+树

与 B 树相比，B+树有以下区别
- 把所有的（关键码，地址）对都放到了叶节点中，内部节点可以看作高层索引，只是为了帮你引导到叶节点
- 存了 $n$ 个数的节点，有 $n$ 个子节点（而非 $n+1$ 个）


![[数算/img/img11/image-3.png]]

那上层节点怎么来的呢？可以取每个子节点中的最大数放到一起，这样 $n$ 个数就对应 $n$ 个区间（$0\sim K_1,\cdots,K_{n-1}\sim K_n$），只需从根节点根据所处区间一直往下走就行

实际上，还可以把叶节点都连起来，形成一个双链表，这样还能支持顺序检索 / 范围检索（需要的话，每一层节点也可以顺序链接）

插入：与 B 树类似，只不过需要保证父节点有分裂出的节点的最大关键码

删除：与 B 树有以下区别
- 下溢边界调整为 $\lceil m/2 \rceil$ 
- 合并时，不能直接从父节点借数，因为父节点的数不是一个实际的（关键码，地址）对，所以我们直接合并两个节点，然后根据合并后的节点的最大值调整父节点
- 删除后，可以沿着到根节点的路径回溯，调整每个节点（因为子节点最大值可能改变），不调整也行（因为子节点仍处在对应区间内，但一般还是会调整的）

>更详细的过程与复杂度分析可以参考 [B+树看这一篇就够了（B+树查找、插入、删除全上） - 知乎](https://zhuanlan.zhihu.com/p/149287061)

## 红黑树

红黑树是一种扩充的 BST 树，是对 BST 的一种改进，BST 树在最坏情况下可能退化成一个链状结构，导致效率大大降低，我们希望在插入和删除时，树仍能保持平衡

红黑树引入“红”和“黑”两种颜色标签，满足
- 根节点和叶节点（扩充出的空节点，称为 NIL ）都是黑色
- 红红限制：不允许两个红色节点直接相连（意味着红色节点的子节点必须是黑色）
- 从任意节点出发的每个外部路径，经过的黑色节点数量相同

黑高：从一个节点出发到叶节点，经过的黑色节点的数量（不包括自身）

>ppt 中将其称之为阶，并定义根的阶就是整个树的阶，但是严格意义上红黑树并没有“阶”这个概念

![[数算/img/img11/image-4.png]]

$k$ 阶红黑树具有以下性质
- 从根到叶的简单路径长度（边数）范围是 $[k,2k]$ ，树高范围是 $[k+1,2k+1]$
- 内部节点最少是 $2^k-1$ （完全满二叉树）
- 内部节点数量为 $n$ 的红黑树，其高度满足 $h\leq 2\log_2(n+1)+1$ （可见红黑树查找的复杂度为 $O(\log n)$ ）

关于第 3 个性质，证明如下：由第 1 个性质，可得

$$h\leq 2k+1$$

由第 2 个性质，可得

$$n\geq 2^k-1$$

综合两个不等式，即可解得

$$h\leq 2\log_2(n+1)+1$$

但是实际上，这个式子通常无法取等，因为第一个不等式取等条件是红黑节点交替出现，第二个不等式取等条件是全是黑色节点，且排成完全满二叉树，当且仅当 $n=1$ 时可以取等（因为根本没法有红色节点）

>网上常见最大树高为 $2\log_2(n+1)$ 的说法，这时 $h$ 实际上采用的是边数高度（即从 0 算起，并认为 $k\geq h/2$ ），而且大多也没有考虑取等情况；这个推导只是给出了一个上界而非上确界，是为了确定时间复杂度的

### 插入

先按 BST 的插入方法放进去，我们规定新插入的节点设为红色，但是这可能违反红红限制，需要进行双红调整

双红调整 1 ：插入节点 X 的父节点 A 是红色，A 的兄弟节点是黑色（由于 A 是红的，所以 B 一定是黑的，不然插入前就违反了原则）

![[数算/img/img11/image-6.png]]

具体有这几种情况

![[数算/img/img11/image-5.png]]

双红调整 2 ：父节点 A 和 A 的兄弟节点都是红色，可以进行换色处理（如果 B 是根节点，则仍保持黑色）

![[数算/img/img11/image-7.png]]

---

比如下面的情况，在一个红黑树中插入了 4 ，违反原则，需要进行双红调整 2 

![[数算/img/img11/image-8.png]]

调整后 7 也违反了原则，需要进行双红调整 1 

![[数算/img/img11/image-9.png]]

最后结果如下

![[数算/img/img11/image-10.png]]

### 删除

先按 BST 的删除方法：把左子树的最大节点 / 右子树最小节点复制到被删除的节点进行替换，然后我们需要删掉这个节点，由于其是左子树中最大的，所以肯定没有右子节点，即至少连接着一个外部节点，则有以下情况

待删除节点连接着 1 个外部节点：由于需要保证各个路径黑高相同，而它直接连接到一个外部节点上，那这个节点肯定为黑色，另一个连接的是红色节点，且这个红色节点连接 2 个外部节点，那就直接把这个红色节点拿上来并变黑即可

![[数算/img/img11/image-11.png]]

待删除节点连接着 2 个外部节点
- 如果待删节点是红色，直接删了（把它和连着的 2 个外部节点搓成 1 个外部节点）
- 如果是黑色，删除后父节点的黑高就不一样了，需要进行双黑调整

>双黑节点：本来你路径上经过一个黑色节点，计数+1，但是现在为了保证黑高相同，需要在经过这个节点时需要计数+2

双黑调整 1 ：如果待删节点的兄弟节点是红色，进行旋转

![[数算/img/img11/image-12.png]]

双黑调整 2 ：如果待删除节点的兄弟节点是黑色，且连着 2 个叶节点
- 把兄弟节点设为红色，父节点设为黑色
- 如果父节点一开始是红色，就完事了；如果一开始是黑色，就还得对父节点进行双黑调整（因为 B 的父节点的黑高变了，原先往 B 这边走会有 B 和 C 2 个黑，现在只有 B 一个黑了）

![[数算/img/img11/image-13.png]]

双黑调整 3 ：如果待删除节点的兄弟节点是黑色，且有红色子节点，需要根据具体情况进行旋转 / 提升操作

![[数算/img/img11/image-14.png]]

![[数算/img/img11/image-15.png]]

### 复杂度分析

检索、插入、删除的平均和最差时间都是 $O(\log n)$ ，因为都是沿着一条路径检索 / 调整，代价就是树高



