
# 基本概念

子串：从一个字符串中截取的一段连续区间（可为空，也可为原字符串）
真子串：非空、非原字符串

>子列：从一个字符串中顺序选一些字符连成串，不要求在原字符串中连续排布

前缀/后缀子串：从一个字符串开头/结尾开始，取一段连续区间（可为空，不可为原字符串，比如 `abcde` 前缀有 `a` `ab` `abc` 等，后缀有 `e` `de` `cde` 等，但均不包含 `abcde` ）

# 实现方式

## 静态存储（C 风格）

- C 风格字符串，使用字符数组 `char s[M]` 实现
- 使用 `\0` 标记字符串结束，ASCII码中 8 个 bit 全为 0 ，又称为 NULL
- 由于存在 `\0` ，所以最大能存的字符串长度为 `M-1`

支持的标准字符串函数如下

| 函数    | 签名                                  | 功能                         |
| ----- | ----------------------------------- | -------------------------- |
| 串长函数  | `int strlen(char *s);`              | 返回字符串 s 的长度                |
| 串复制   | `char* strcpy(char *s1, char *s2);` | 将 s2 值复制给 s1，返回 s1 的指针     |
| 串拼接   | `char* strcat(char *s1, char *s2);` | 将串 s2 拼接到 s1 的尾部，返回 s1 的指针 |
| 串比较   | `int strcmp(char *s1, char *s2);`   | 比较 s1 和 s2 的大小             |
| (左)定位 | `char* strchr(char *s, char c);`    | 从左往右找 c 在 s 中第一次出现的位置      |
| 右定位   | `char* strrchr(char *s, char c);`   | 从右往左找 c 在 s 中第一次出现的位置      |

下面贴一个程设的代码

```cpp
int strlen(const char *s) {
    int i = 0;
    while (s[i]) 
        ++i;
    return i;
}

void strcpy(char *d, const char *s) {
    int i = 0;
    while (s[i]) {
        d[i] = s[i];
        ++i;
    }
    d[i] = '\0'; // 添加字符串结束符
}

int strcmp(const char *s1, const char *s2) {
    int i = 0;
    while (s1[i] && s2[i]) {
        if (s1[i] < s2[i]) 
            return -1;
        else if (s1[i] > s2[i]) 
            return 1;
        ++i;
    }
    if (!s1[i] && s2[i]) 
        return -1;
    else if (s1[i] && !s2[i]) 
        return 1;
    return 0;
}

void strcat(char *d, const char *s) {
    int len = strlen(d);
    int i = 0;
    while (s[i]) {
        d[len + i] = s[i];
        ++i;
    }
    d[len + i] = '\0'; // 添加字符串结束符
}
```

## 动态存储（String 类）

不限制最大长度，采用一种动态的存储结构（不适合用链表，因为存在内存对齐，但每个节点只存一个 char 和一个指针，这导致存储空间利用率很低）

下面贴一个程设的代码

```cpp
class MyString {
    char *p; // 动态分配的 C 风格字符串

public:
    // 构造函数
    MyString(const char *s = "") {
        if (s) {
            p = new char[strlen(s) + 1];
            strcpy(p, s);
        } else {
            p = nullptr;
        }
    }

    // 析构函数
    ~MyString() {
        if (p)
            delete[] p;
    }

    // 拷贝构造函数
    MyString(const MyString &other) {
        if (other.p) {
            p = new char[strlen(other.p) + 1];
            strcpy(p, other.p);
        } else {
            p = nullptr;
        }
    }

    // 拷贝赋值运算符
    MyString &operator=(const MyString &other) {
        if (this == &other)
            return *this; // 防止自赋值
        if (p)
            delete[] p;
        if (other.p) {
            p = new char[strlen(other.p) + 1];
            strcpy(p, other.p);
        } else {
            p = nullptr;
        }
        return *this;
    }

    // 从 C 字符串赋值运算符
    MyString& operator=(const char *s) {
        if (p)
            delete[] p;
        if (s) {
            p = new char[strlen(s) + 1];
            strcpy(p, s);
        } else {
            p = nullptr;
        }
        return *this;
    }

    // 字符串拼接（加号运算符重载）
    MyString operator+(const MyString &other) const {
        int len1 = p ? strlen(p) : 0;
        int len2 = other.p ? strlen(other.p) : 0;
        char *newStr = new char[len1 + len2 + 1];
        if (p)
            strcpy(newStr, p);
        else
            newStr[0] = '\0';
        if (other.p)
            strcat(newStr, other.p);
        MyString result(newStr);
        delete[] newStr;
        return result;
    }

    MyString operator+(const char *s) const {
        return *this + MyString(s);
    }

    friend MyString operator+(const char *s, const MyString &str) {
        return MyString(s) + str;
    }

    // 累加赋值运算符重载
    MyString &operator+=(const char *s) {
        *this = *this + MyString(s);
        return *this;
    }

    // 下标运算符重载
    char &operator[](int index) {
        return p[index];
    }

    // 下标运算符重载 (const 版本)
    const char &operator[](int index) const {
        return p[index];
    }

    // 小于运算符重载
    bool operator<(const MyString &other) const {
        return strcmp(p, other.p) < 0;
    }

    // 等于运算符重载
    bool operator==(const MyString &other) const {
        return strcmp(p, other.p) == 0;
    }

    // 大于运算符重载
    bool operator>(const MyString &other) const {
        return strcmp(p, other.p) > 0;
    }

    // 截取子串运算符重载
    MyString operator()(int start, int length) const {
        if (!p || start < 0 || start >= strlen(p)) {
            return MyString("");
        }
        char *subStr = new char[length + 1];
        int i = 0;
        for (; i < length && p[start + i]; ++i) {
            subStr[i] = p[start + i];
        }
        subStr[i] = '\0'; // 添加字符串结束符
        MyString result(subStr);
        delete[] subStr;
        return result;
    }

    // 输出运算符重载
    friend ostream &operator<<(ostream &os, const MyString &s) {
        if (s.p)
            os << s.p;
        return os;
    }
};

// 比较函数
int CompareString(const void *e1, const void *e2) {
    MyString *s1 = (MyString *)e1;
    MyString *s2 = (MyString *)e2;
    if (*s1 < *s2)
        return -1;
    else if (*s1 == *s2)
        return 0;
    else
        return 1;
}
```

# 模式匹配

问题：给定子串 P （模板 pattern），求其在目标字符串 T 中的首次出现位置（从左往右看，返回匹配区间的首个字符的位置）

## 朴素匹配（遍历）

将 P 在 T 上滑动，每次滑动后依次比对，假设 P 长度为 m ，T 长度为 n ，则这个算法是 $\Omega(m)$ 和 $O(m\cdot n)$ 的

这有三种实现方式，但实现的效果都是一样的
1. 采用 `substr` 从左往右获取 T 的每个长度为 m 的子串，并与 P 进行比较
2. 采用双层循环，外层在 T 上逐步移动作为起点，内层逐字符比较二者是否匹配
3. 只用一层循环，维护两个指针 t 和 p ，分别在 T 和 P 上移动，检测二者相应位置是否匹配：若匹配，则两个指针都往下移动；若不匹配，则将 t 回退到匹配起点的下一个位置 `t-p+1` ，将 p 重置为 0 

## KMP

上面的第 3 种实现方式只用了一个循环，初具雏形，但是每次不匹配都要把指针回溯和重置，这在很多情况下是不必要的，因为之前我们已经检测了一部分的匹配情况，但后续的检测并没有利用这部分信息，比如以下情况

![[数算/img/img4/image.png]]

但其实在第一步，我们已经知道 $P_0...P_4$ 和 $T_0...T_4$ 是匹配的了，即可以得出

$$P_i=T_i\quad(i=0,1,2,3,4)$$

同时，观察 P 可得

$$P_0 \neq P_1$$

结合 $P_1=T_1$ ，那么就可以推断出

$$P_0\neq T_1$$

所以上面的第 2 步比较其实是没必要做的，同理第 3 4 步也没必要做，直到第 5 步 $P_1=T_5$ 的判断才是有用的，即能提供更多的信息

也就是说，我们需要根据 P 本身和已经检测到的匹配部分，推断出指针移动到哪里才是有用的

---

假设我们在某时刻检测到了以下的匹配情况

![[数算/img/img4/image-1.png]]

则有

$$P_0 \cdots P_{i-1} = S_{j-i} \cdots S_{j-1}$$

如果 $P_0 \cdots P_{i-2} \neq P_1 \cdots P_{i-1}$ ，又由上式可得 $P_1 \cdots P_{i-1} = S_{j-i+1} \cdots S_{j-1}$ ，则可推断出

$$P_0 \cdots P_{i-2} \neq S_{j-i+1} \cdots S_{j-1}$$

即将 P 往下移动 1 位仍是不匹配的，后续情况同理

直到对于某一个 $k$ 值，使得

$$P_0 \cdots P_{k-1} = P_{i-k} \cdots P_{i-1}$$

那么就可以推断出

$$P_0 \cdots P_{k-1} = S_{j-k} \cdots S_{j-1}$$

这时我们需要检测 $S_j = P_k$ ，这就提供了额外信息，也就是说我们下一步要把 P 上的指针 p 移到 $k$ 处，而 T 上的指针 t 保持不变

那如果有多个 $k$ 怎么选取呢？对于更小的 $k$ ，这会导致移动后 T 与 P 中更靠前的位置对齐进行比较，相当于 P 在 T 上移动的更多了，这容易错过一些正确的匹配区间，所以应该选取最大的 $k$

```
T: ...abababx...    T: ...abababx...
        ||||^                 ||^
P:      abababc     P:        abababc
index:  0123456               0123456
			^                   ^
   [big k]               [small k]
```

>由于更长的前缀包含更短的前缀，所以如果有多个 $k$ ，它们应该是相连的

## 特征数

上述过程中，$i$ 可以根据指针 p 的位置确定，问题就变成了在 $P_0 \cdots P_{i-1}$ 上找到最大的 $k$ ，使得 $P_0 \cdots P_{k-1} = P_{i-k} \cdots P_{i-1}$ ，即找到这个子串的最长相等前后缀

在已知 $i$ 的情况下，这就只和 P 自身长什么样有关，为此可以构建一个数组，储存不同 $i$ 值对应的 $k$ 值，用的时候直接查找就完了，这个 $k$ 值就被称为 P 的**特征数** $n_i$ ，而这个数组叫做 **next 数组**

我们规定下标 0 处对应的特征数为 -1 ，这代表 P 上来就和 T 不匹配，那么应该将指针 t 往下移动一步，同时指针 p 设为 0 ，重新从 P 的开头开始匹配（如果设为 0 ，会导致两个指针都不变，就卡死了）

而后可以用递归的方式计算后续特征数，假设 $n_i=k$ ，即在 $P_0 \cdots P_{i-1}$ 中，最长匹配前后缀为 $P_0 \cdots P_{k-1} = P_{i-k} \cdots P_{i-1}$ ，现计算 $n_{i+1}$ 的值，即在 $P_0 \cdots P_{i}$ 中找到新的最长匹配前后缀

由于尾部多了一个 $P_i$ ，所以后缀变为以 $P_i$ 结尾，如果 $P_i=P_k$ ，由于我们已知 $P_0 \cdots P_{k-1} = P_{i-k} \cdots P_{i-1}$ ，那么 $P_0 \cdots P_{k} = P_{i-k} \cdots P_{i}$ ，这就是新的最长匹配前后缀（再进行延伸就不匹配了，因为 $i$ 时最长的就到 $k$ ），则 $n_{i+1}=k+1$

如果 $P_i\neq P_k$ ，而且 $k=0$ ，说明原来就匹配不上，现在加进来的字符也匹配不上，那 $n_{i+1}=0$

如果 $P_i\neq P_k$ ，而且 $k\neq 0$ ，说明 $P_0 \cdots P_{k} \neq P_{i-k} \cdots P_{i}$ ，我们退而求其次，考虑找到一个 $l<k$ ，使得 $P_0 \cdots P_{l} = P_{i-l} \cdots P_{i}$ ，这可以进一步拆分为两部分

$$P_0\cdots P_{l-1}=P_{i-l}\cdots P_{i-1} \quad\text{and}\quad P_i=P_l$$

由于 $P_0 \cdots P_{k-1} = P_{i-k} \cdots P_{i-1}$ ，且 $l<k$ ，故二者长度为 $l$ 的后缀也相同

$$P_{k-l}\cdots P_{k-1}=P_{i-l}\cdots P_{i-1}$$

那么第一部分就变成了

$$P_0\cdots P_{l-1}=P_{k-l}\cdots P_{k-1}$$

这就正好与 $n_k=l$ 的含义相同，所以要找的 $l$ 就是 $n_k$ ，接下来只需判断 $P_i=P_l$ ，如果还不相等，那么就这么递归的做下去

上述过程的总结和 KMP 代码如下
1. 若 `p[i] == p[k]` ，则 `n[i+1] = k+1` 
2. 若 `p[i] != p[k]` 且 ` k == 0` ，则 `n[i+1] = 0` 
3. 若 `p[i] != p[k]` 且 ` k > 0` ，则令 `k = n[k]` ，重新进行这些判断，直到能计算出 `n[i+1]` 

```cpp
// 构建next数组
vector<int> buildNext(const string& pattern) {
    int m = pattern.size();
    vector<int> next(m, 0);
    next[0] = -1;
    int k = -1;
    for (int i = 1; i < m - 1; i++) {
	    // 退出时要么p[i]==p[k]，要么k=-1
        while (k >= 0 && pattern[i] != pattern[k]) {
            k = next[k];
        }
        k++;
        next[i] = k;
    }
    return next;
}

// KMP主算法
int kmp(const string& text, const string& pattern) {
    vector<int> next = buildNext(pattern);
    int j = 0;
    for (int i = 0; i < text.size(); i++) {
        // 不匹配时通过next数组跳转
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }
        // 当前字符匹配，移动模式串指针
        if (text[i] == pattern[j]) {
            j++;
        }
        // 完全匹配成功
        if (j == pattern.size()) {
            return i - j + 1;  // 返回匹配起始位置
        }
    }
    return -1;  // 未找到
}
```

计算 `next` 数组的时间复杂度为 $O(m)$ ，KMP 的遍历部分的时间复杂度为 $O(n)$ ，总的时间复杂度为 $O(m+n)$ ，下面贴个运行过程的例子

![[数算/img/img4/image-2.png]]


















