
# 树与森林

树的定义与二叉树类似，都是递归的形式，有如下表示方法

![[数算/img/img6/image.png]]

树的度：树中的节点的分叉数的最大值
有序树：每一层的节点从左往右排列并编号

值得注意的是，度为 2 的有序树不是二叉树，因为有序树中不会出现没有左子树，但是有右子树的情况，但二叉树允许

## 森林与二叉树的转化

森林：多个不相交的树组成的集合（通常是有序的，即树的顺序是有意义的）

>尽管兄弟节点的定义是有同一个父节点的节点，但是在森林中，规定所有树的根节点互为兄弟

每个森林都唯一对应到一个二叉树，而一个非空二叉树也可以转化成一个森林

从森林转换到二叉树时，先把每一层所有相邻的兄弟之间加一个连线；而后对于每个节点，除了其与最左子节点的连线，把与其它子节点的连线都删了；最后把树转一下变为正常视角

![[数算/img/img6/image-1.png]]

>这里及以后的“转换”代表的都是这种算法，即便这个树本来就是二叉树，经过这种转换后它变得不一样了

由此可见，如果森林中只有一个树，其转换成的二叉树就没有右子树

在最后一步的旋转整个树时，实际上是根据连线属性确定左右子节点
- 父子连线（即每个节点与其最左子节点之间的连线）被转换为二叉树中的左子节点指针
- 兄弟连线被转换为二叉树中的右子节点指针

上面的过程可以总结为以下理论表述：设森林 $F$ 是树 $(T_1,...,T_n)$ 的有序集合，转换成的二叉树记作 $B(F)$ ，则 $B(F)$ 的根节点是 $T_1$ 的根节点 $R_1$ ；$B(F)$ 的左子树为 $R1$ 的所有子树 $(T_{11},...,T_{1m})$ 转换成的二叉树 $B(T_{11},...,T_{1m})$ ；右子树为 $B(T_2,...,T_n)$ 

---

把二叉树转换为森林的过程与之类似，把二叉树的根节点与其右子节点的连线、右子节点与右子节点的右子节点的连线等，全都删了；再把这些孤立的二叉树转化成多叉树

![[数算/img/img6/image-3.png]]

那咋把二叉树转化成多叉树呢？如果一个节点是其父节点的左子节点，就把它的右子节点、它的右子节点的右子节点等，都和这个节点的父节点连起来；然后把原来的二叉树中的父节点与右子节点的连线删掉；最后重新调整层次结构

![[数算/img/img6/image-2.png]]

上面的过程可以总结为以下理论表述：设二叉树 $B$ 的根节点为 $R$ ，左右子树为 $T_L$ 和 $T_R$ ，记其转换成的森林为 $F(B)$ ，则 $F(B)$ 为一个树 $T_1$ 和 $F(T_R)$ ，其中 $T_1$ 以 $R$ 为根节点、$F(T_L)$ 中的树为子树 

## 多叉树的周游

- 深度优先
	- 先根次序：先访问根节点，再从左到右遍历子树
	- 后根次序：先从左到右遍历子树，再访问根节点
- 广度优先（层次遍历）

![[数算/img/img6/image-4.png]]

值得注意的是，先根次序周游的遍历顺序等价于对应二叉树的前序周游，后根次序周游则等价于对应二叉树的中序周游


# 链式存储

## 子节点表示法

用一个数组来存储所有节点，每个节点会存储父节点下标，以及所有子节点下标组成的链表
- 容易确定子节点个数和查找节点的值
- 给定一个节点，要找其兄弟节点比较困难
- 易于进行树的合并，只需把一个树的根添加到另一个树的某个节点的子节点链表中

![[数算/img/img6/image-5.png]]

## 动态节点表示法

子节点表示法中，所有节点都被放在一个数组里边，要调整大小只能重新分配数组，考虑用链表的方式，每个节点存储父节点和其子节点指针构成的数组，这就是 **指针数组法** 

![[数算/img/img6/image-6.png]]

或者每个节点存储父节点和其子节点指针构成的链表，这就是 **指针链表法** 

![[数算/img/img6/image-7.png]]

此外，我们只需再存储这个树的根节点的指针，就能访问这个树

## 静态“左孩子/右兄弟”表示法

前面两个方法仍然没有解决查找某个节点的兄弟节点比较困难的问题，其实每个节点可以不用存储其所有子节点，而是存储其父节点、左子节点和右侧相邻的兄弟节点，这样既能方便的访问所有子节点（先访问左子节点，再访问左子节点的右兄弟），也便于查找一个节点的兄弟节点（右侧直接能获取，左侧可以先找到父节点的左子节点，再往右找）

在合并两个树时，只需改动一下连接处的节点的信息即可

![[数算/img/img6/image-8.png]]

这种方式不仅便于兄弟节点的查找，每个节点只需要固定大小的存储空间，提高了空间效率

实际上，存储一个森林时，也可以这么做，对于森林 $(T_1,...,T_n)$ 只需存储 $T_1$ 的根节点 $R_1$ 代表这个森林，把 $T_2\ ...\ T_n$ 的根节点全都视为 $R_1$ 的右兄弟，依次存储即可

## 动态“左孩子/右兄弟”二叉链表表示法

只需把静态左孩子右兄弟中的数组下标换为链表指针即可，这与先把一个树转换为二叉树，再用链表的方式存储这个二叉树是等价的

树节点的代码实现如下，每个节点存储左孩子和右兄弟（当然也可以加上父节点，反正就多一个变量）

```cpp
T Value;
TreeNode<T>* pChild; // 左孩子
TreeNode<T>* pSibling; // 右兄弟
```

对于一个节点，如果要把另一个节点作为它的第一个子节点（左孩子）插入进去，则代码如下

```cpp
void TreeNode<T>::InsertFirst(TreeNode<T>* node)
{
    if (pChild) { // 左孩子非空
        node->pSibling = pChild; // 原来的左孩子成了新节点的右兄弟
        pChild = node; // 新节点变为左孩子
    }
    else {
        pChild = node; // 左孩子为空，直接把新的节点放进来就行
    }
}
```

整个树的代码实现如下，需要先存一个树根 `TreeNode* root` ，假设节点中没有储存父节点，那就需要用搜索的方式去查找某个节点 `node` 的父节点，可以用广搜

```cpp
template <class T>
TreeNode<T>* Tree<T>::Parent(TreeNode<T>* node) {
    using std::queue;
    queue<TreeNode<T>*> aQueue;
    TreeNode<T>* pointer = root; // 当前访问的节点，初始为根节点
    TreeNode<T>* upperlevelpointer = NULL;
    if (node == NULL || pointer == node) // node为空或为根节点
	    return Null; // 说明其根本没有父节点
	// 把根节点及其所有右兄弟加到队列（应对森林的情况）
	while (pointer) {
		if (node == pointer)
			return NULL;
		aQueue.push(pointer);
		pointer = pointer->RightSibling();
	}
	// 查找当前节点的所有子节点包不包括node
	while (!aQueue.empty()) {
		pointer = aQueue.pop();
		upperlevelpointer = pointer; // 记录当前节点
		pointer = pointer->LeftMostChild(); // 移到左子节点
		// 向右遍历所有子节点，不是node就加入队列
		while (pointer) {
			if (node == pointer)
				return upperlevelpointer;
			else {
				aQueue.push(pointer);
				pointer = pointer->RightSibling();
			}
		}
	}
    return NULL;
}
```

删除以某个节点 `root` 代表的森林时，我们要删除其子树和所有右兄弟的子树，可以通过后根次序递归删除，这相当于把这个树转换为二叉树后，删除以 `root` 为根节点的子树

```cpp
template <class T>
void Tree<T>::DestroyNodes(TreeNode<T>* root) {
    if (root) {
        DestroyNodes(root->LeftMostChild());
        DestroyNodes(root->RightSibling());
        delete root;
    }
}
```

删除以某个节点为根节点的子树时，我们需要调整与其相关的节点所存储的信息

```cpp
template <class T>
void Tree<T>::DeleteSubTree(TreeNode<T>* subroot) {
    TreeNode<T>* pointer = PrevSibling(subroot); // 获取左兄弟
    if (pointer == NULL) { // 左兄弟为空，说明subroot就是最左的节点
        pointer = Parent(subroot); // 移动到其父节点
        if (pointer) { // 父节点非空
	        // 把父节点的左孩子设为subroot的右兄弟
            pointer->pChild = subroot->RightSibling();
        } else {  // 父节点为空，说明subroot是整个树的根节点
	        // 把森林的root设为subroot的右兄弟
            root = subroot->RightSibling();
        }
    } else { // 左兄弟非空
	    // 把subroot的左兄弟的右兄弟设为subroot的右兄弟
        pointer->pSibling = subroot->RightSibling();
    }
    // 将subroot的右兄弟设为空，避免调用DestroyNodes时删除右兄弟
    subroot->pSibling = NULL;
    DestroyNodes(subroot);
}
```

## 父指针表示法

一些应用场景中（比如下面的并查集），只需要直到父节点情况，每个节点保存一个其父节点的指针即可，由于每个节点父指针唯一，故这个方法可以唯一表示一个树

![[数算/img/img6/image-9.png]]

如果要判断两个节点在不在一个树里，只需要沿着父节点一直往上走，看两个节点所在树的根节点是不是一样的

# 并查集与等价类

关于**等价关系**的数学定义太理论了，通俗的理解，就是我们认为 $x$ 和 $y$ 在某种意义或者标准下，可以认为是一回事，这就构成一个等价对 $(x,y)$ ，其具有自反性、对称性、传递性，而**等价类**就是与 $x$ 等价的元素构成的集合

但是一般来讲，我们只有一堆零散的等价对，这很不直观，可以把它们的等价关系用一个树来表示，这就是**并查集**，父子节点的连线就表示二者是等价的，同一个树中的节点都是等价的，构成一个等价类

我们的目标就是要根据一系列等价对构建出并查集，考虑两种基本操作
- `find` ：查找某个节点所在树的根节点，用于判断不同节点在不在一个树里（也可以实现为 `different` ，直接判断两个元素在不在一个树）
- `union` ：把两个树合并，如果两个节点不在一个树里，但通过等价对又知道它们是等价的，就需要通过 union 把它们所在的树合并

在合并时，为了防止合并后的树太不平衡了，需要按照**重量权衡合并规则 weighted union rule** 进行，即将节点较少的树的根节点连接到节点较多的树的根节点上，这可以把整个树的深度限制在 $O(\text{log}n)$ 

![[数算/img/img6/image 1.png]]
![[image-1 1.png]]
![[image-2 1.png]]

## 路径压缩算法

按照上述方法构建出的并查集可能很长，比如

```
.   A
.   |
.   B
.   |
.   C
.  / \
. D   F
. |
. E
```

但实际上，由于一个树里的节点都是等价的，最理想的情况是把所有子节点都连到整个树的根节点上

```
.      A
.  / / | \ \
. B  C D E  F 
```

此外，执行 `find(E)` 时，往上走经过 DCB 最后到根节点 A ，这也表明 DCB 所在树的根节点也是 A ，但是后续执行 `find(D)` 时，还要沿着路径走一遍，这太浪费时间了

路径压缩算法把这两个过程结合，在 `find` 时顺便进行优化，将查找路径上的所有节点直接连到根节点，极大地扁平化树结构，从而为后续操作提供近乎常数时间的性能，比如执行 `find(E)` 时，就把 EDCB 全都连到 A 上

```
.    A
.  / | \ \ 
. B  C  D E  
.    |
.    F
```

# 顺序存储

既然是顺序的，就需要确定一个存储顺序，可以使用先根/后根/层次次序，并结合一些额外的信息以确保能还原出树结构

此外我们规定一个节点的子节点是从左往右排列的，以保证还原结果唯一，如果不符合这种情况，需要补充一些子节点

## 带右链的先根次序表示法

先根遍历的顺序有以下特点
- 一个节点的子树中的节点直接跟在该节点之后，且中间不会插入其它部分的节点
- 一个节点若存在子节点，则其第一个子节点（最左子节点）紧跟着它出现

从前面我们知道，只需确定每个节点的左孩子和右兄弟，就能还原出树结构，所以问题的关键变成了怎么根据存储顺序和额外信息确定一个节点的左孩子和右兄弟，对于先根次序，确定左孩子很好办，只需存储其有没有孩子即可，此外我们可以直接存储其右兄弟的位置
- `rlink` ：下一个右兄弟的位置（设为空或特殊值代表没有）
- `ltag` ：有没有子节点（ 0 是有，1 是没有）

![[image-3 1.png]]

```
index 0  1  2  3  4  5  6  7  8  9
rlink 7  5  3  4 -1  6 -1 -1  9 -1 
info  C  E  J  K  L  F  G  D  X  I 
ltag  0  0  1  1  1  1  1  0  1  1
```

## 带双标记位的先根次序表示法

但是如果你使用上面的表示法还原树结构时就会发现，其实存储右兄弟的具体下标是完全多余的，只需要存储有没有右兄弟就行了，其位置完全可以推断出来
- `ltag` ：有没有子节点（ 0 是有，1 是没有）
- `rtag` ：有没有右兄弟（ 0 是有，1 是没有）

考虑这么一个树，从双标记位表示法进行还原

![[image-4 1.png]]

- 第一个节点 A 肯定是根节点，其有子节点，那么下一个节点 B 就是其第一个子节点；此外还得知 A 有右兄弟，这个待会再考虑
- B 无子节点，有右兄弟，那下一个节点 C 就是它的右兄弟
- C 有子节点，下一个节点 K 就是其子节点；C 无右兄弟，说明 A 的子节点只有 B C 
- K 无子节点，也无右兄弟，说明 A 对应的这个树到这里就结束了，那下一个节点 D 就是另一个树的根节点，正好对应 A 的右兄弟

从上述过程可以发现，每个有兄弟节点都对应一个无孩子节点，而这个无孩子节点的下一个节点，就是有兄弟节点的右兄弟，我们可以采用栈的结构
- 遇到有兄弟节点 `rtag == 0` ，入栈
- 遇到无孩子节点 `ltag == 1` ，弹出
- 将下一个节点设为弹出节点的右兄弟

比如上面的树
- A 有兄弟有孩子，入栈，此时 `stack: A`
- B 有兄弟，入栈；但其无孩子，立刻弹出，下一个节点 C 就是其右兄弟
- C 无兄弟，不入栈，此时仍是 `stack: A`
- K 无兄弟，不入栈；无孩子，弹出 A ，那 A 的右兄弟就是下一个节点 D 

>另外还可以发现，如果一个节点的两个 tag 都是 1 ，那下一个节点就是新的一个树的根节点

## 带度数的后根次序表示法

用后根次序存储，附带每个节点的度数

![[image-5 1.png]]

在还原时，如果一个节点度数为 0 ，说明其是叶节点，也可以看作一个单节点子树的根节点；如果一个节点的度数为 k ，那它前面 k 个（是某个子树的根节点的）节点就是其子节点，这也可以用栈实现
- 遇到度数为 0 的节点，入栈
- 遇到度数为 k 的节点，弹出 k 个节点作为其子节点，然后将其入栈

>带度数的先根/层次次序虽然也能还原，但还原时不一定这么简便

## 带双标记的层次次序表示

与带双标记的先根次序类似，也存储同样的标记，只不过由于是层次次序（广搜遍历顺序），当 `rtag == 1` 时，下一个节点就是其右兄弟

这里我们根据“有孩子-无兄弟”的对应关系，确定有孩子节点的第一个子节点，比如下图，A 有孩子，G 无兄弟，则 A 的第一个孩子是 G 的下一个节点 B ；G 有孩子，D 无兄弟，则 G 的第一个孩子是 H ；C 有孩子，I 无兄弟，则 C 的第一个孩子是 E 

![[image-6 1.png]]

这可以用队列实现
- 遇到 `ltag == 0` 入队列
- 遇到 `rtag == 1` 弹出，将下一个节点设为弹出节点的左孩子

那为啥前面先根次序用栈，这里又用队列了呢？因为栈/队列的特性正好与深搜/广搜对应，如果这里用栈实现，考虑以下例子

```
.      A
.     / \
.    B   C
.   /   / \
.  D   E   F
```

- A 有孩子，入；无兄弟，出，其左孩子为 B 
- B 有孩子有兄弟，入
- C 有孩子，入，此时容器内有 `B C` ；无兄弟，出，如果用的是栈，会把 C 弹出来，然后将其左孩子设为 D ，这就错了；如果用的是队列，会把 B 弹出，将其左孩子设为 D ，这是正确的

## 前序字符串表示

用先根次序进行遍历，回退时进行记录

![[image-7 1.png]]







