
# 问题求解

解决问题需要：数据结构 + 算法

以下面一个问题为例，其中 C E 道路只能按照规定方向走，允许从一个道路移动到另一个道路，现在要规划出一种方案，使得不同车流通过路口时不会冲突

![[数算/img/img1/image.png]]

这个问题可以归结为对车辆的可能行驶方向作某种分组，对分组的要求是使任一个组中各个方向行驶的车辆可以同时安全行驶而不发生碰撞

根据路口情况，可以确定这 13 个可能通行方向：A→B，A→C，A→D， B→A，B→C，B→D， D→A，D→B，D→C， E→A，E→B，E→C， E→D

为了叙述方便，下面把 A→B 简写成 AB ，在不能同时行驶的路线间画一条连线，表示它们互相冲突，便可以得到下图

![[数算/img/img1/image-1.png]]

那问题就变成了将图中的节点分组，使有线相连的节点不在同一个组里，可以发现，这与着色问题类似：相邻即相互冲突，染不同颜色即分组

---

具体编程时，需要先决定用什么数据类型代表这个结构图和一组节点，可以使用一个图结构表示地图，使用节点名的集合表示分组

而后需要确定算法，一个简单的方法是贪心法，随便选一个颜色尽可能染色更多的区域，然后从剩下的颜色和区域里再这么做

设需要着色的图是 G ，用集合 V1 代表所有未着色的节点，用 V2 代表已着色的节点，则伪代码如下

```cpp
int colorUp(Graph G)
{
    int color = 0; // 所需颜色数量
    V1 = G.V;
    while(!isEmpty(V1)) // 如果V1非空
    {
        setEmpty(V2);  // 清空V2
        // 判断G中节点v是否与V2中的节点相连
        while (v ∈ V1 && notAdjacentWithSet(V2, v, G))
        {
            addToSet(V2, v); // v加入V2
            removeFromSet(V1, v); // 将v从V1中删除
        }
        printSet(V2); // 输出当前V2中的节点
        ++color; // 所需颜色数量+1
    }
    return (color);
}

```

但显然，贪心法不一定能给出最优解

# 数据结构

**数据结构三要素**：逻辑 + 存储 + 运算

Bit 比特/位：最小的存储单位，值只能为 `0` 或 `1`，即二进制中的一位
Byte 字节：计算机数据存储的基本单位，`1Byte = 8bit`

下面是一些基本的数据类型
- 整数类型：大小取决于所用语言和系统的位数，如 4B 或 8B
- 实数类型：大小为 4B（单精度） 或 8B（双精度）
- 布尔类型：大小为 1 B
- 字符类型：ASCII 字符大小为 1B ，汉字字符大小为 2B
- 指针类型：大小取决于系统，如 4B 或 8B
	- 32位系统：指针长度 4B （32位），表示范围：$0 \sim 2^{32}-1$
	- 64位系统：指针长度 8B （64位），表示范围：$0 \sim 2^{64}-1$

复合数据类型：基本数据类型/复合类型组成的复杂结构

>`struct` 和 `class` 的区别
>1. 结构的默认访问类型是 public，类的默认访问类型为 private 
>2. 结构是实值类型，类则是引用类型
>3. 结构使用栈存储，类使用堆存储（栈的执行效率要比堆的执行效率高，但是栈资源却很有限， 不适合处理逻辑复杂的大对象）

下面是一个特殊例子

```cpp
struct Data
{
	char a; // 大小1B
	char* p; // 32位系统大小4B
}
```

这个结构体占用的内存大小是 8B 而非 5B ，这是因为**内存对齐**的机制，所以反正都得占这么多地方，不如把 `char a` 换为 `char a[4]`

## 逻辑结构

逻辑结构 = 数据节点 + 节点间的二元关系
- 节点集合 K ：由有限个节点组成，代表一组有明确结构的数据集
- 关系集合 R ：定义在集合 K 上的一组关系，每个关系 $r \in R$ 都是 K×K 上的二元关系， 描述结点间的逻辑关系
- 对于 $\text{<k1,k2>} \in R$ , 称 k1 为 k2 的**前驱**，k2 为 k1 的**后继**；没有前驱的节点为开始节点, 没有后继的节点为终端节点

一些常见的结构类型
- 线性结构：线性表（表，栈，队列，串等） 
- 非线性结构
	- 树（二叉树，Huffman树， 二叉检索树等）
	- 图（有向图，无向图等）
	- 图 ⊇ 树 ⊇ 二叉树 ⊇ 线性表

集合结构：关系集合 R 为空
线性结构：每个节点最多只有一个前驱和一个后继
树形结构：又称层次结构，每个节点可以有多个后继，但至多有一个前驱
图结构：前驱、后继结点的个数都不作限制

## 存储结构

存储可以看作逻辑结构到物理存储空间的映射

计算机主存储器：内存
- 非负整数作为地址编码，是一系列相邻单元的集合，基本单位是字节
- 支持按地址随机访问，访问不同地址所需时间基本相同

对于节点集合 K ，其中的每个节点数据都对应一个连续的存储区域
对于关系的存储，有四种方式：顺序、链接、索引、散列
- 顺序方法：把一组节点存储在地址相邻的顺序存储单元里，存储单元的顺序表示节点间的逻辑后继关系
- 链接方法：在节点的存储结构中附加指针，于是一个存储单元就分成了数据域 E 和指针域 P 两部分，其中数据域存储的是节点本身的数据
- 索引方法：通过索引访问数据，每个节点都有一个索引值和存储地址，所有索引值组成一个索引表，访问数据时先按序从索引表查找对应索引，而后根据索引访问具体数据
- 散列方法 hashing ：索引方法的延伸，使用一个散列函数，将键直接计算成一个存储地址（桶号）

## 数据运算

- 常用的运算：检索、插入、删除、定位、修改、排序等
- 数据的运算是定义在逻辑结构上的，而具体实现是基于存储结构

## 抽象数据类型 ADT (Abstract Data Type)

ADT ：定义了一组运算的数学模型
- 与物理存储结构无关
- 使软件系统建立在数据之上（面向对象）

**ADT 三元组**： <数据对象 D ，数据关系 S ，数据操作 P >
- 先定义逻辑结构（数据对象+ 数据关系），再定义运算 （数据操作）

以栈为例，假设我们要实现一个栈的数据类型，需要先明确其逻辑结构，很明显这是一个线性表

而后需要明确数据操作，应包括以下基本操作
- 限制访问端口：只允许在一端进行插入，删除操作
- 入栈 push ，出栈 pop ，取栈顶 top ，判栈空 isEmpty

据此可得到以下代码

```cpp
template <class T> // 栈的元素类型为 T
class Stack 
{                          
public:
    void clear(); // 变为空栈
    bool push(const T item); // item入栈，成功返回真，否则假
    bool pop(T & item); // 弹栈顶，成功返回真，否则返回假
    bool top(T& item); // 读栈顶但不弹出，成功真，否则假
    bool isEmpty(); // 若栈已空返回真
    bool isFull(); // 若栈已满返回真
};
```

# 算法复杂度分析

时间代价（复杂性）：算法执行时间随数据规模增长的变化趋势，记为 $F(n)$
- 时间单位：执行一条基本语句（如判断、算术运算）所用的时间
空间代价（复杂性）：算法占用内存随数据规模增长的变化趋势，记为 $G(n)$
- 空间单位：一个基本类型的变量占用的内存

对于一个算法，往往难以精确表示出其时间与空间代价，所以考虑用其增长速度的量级去描述，下以时间复杂度为例

**大 O 表示法**：表示函数增长率的上限，即一个算法最慢能到什么程度
大 $\Omega$ 表示法：表示函数增长率的下限，即一个算法最快能到什么程度
大 $\Theta$ 表示法：若算法的增长率是固定的，即 O 和 $\Omega$ 一样，就能用 $\Theta$ 统一表示

衡量增长率时，一般关注在增长时起主导作用的那一项，而忽略其它项，比如一个算法的时间代价是 
$$F(n)=10n^2+100n+\text{log}_{10}n+1000$$
可以发现其中增长最快的项是 $10n^2$ ，那其增长率就是 $n^2$ 级别的，则这个算法是 $\Theta(n^2)$ 的

但是一些算法的实际运行速度是取决于给的数据的，比如插入排序，其过程是从左往右遍历数组，将当前的数插入其左侧已经排序好的序列（从右往左比较）

```cpp
void insertionSort(vector<int>& arr) 
{ 
	int n = arr.size(); // 从第二个元素开始（索引1） 
	for (int i = 1; i < n; i++) 
	{ 
		int current = arr[i]; // 当前要插入的元素 
		int j = i - 1; 
		// 在已排序部分中找到 key 的插入位置 
		while (j >= 0 && arr[j] > current) 
		{ 
			arr[j + 1] = arr[j]; // 向右移动比 current 大的元素 
			j--; 
		} 
		arr[j + 1] = current; // 把 current 插入到正确位置 
	}
} 
```

但是这个算法的执行速度依赖于数组长什么样，如果数组一开始就排序好了，遍历一遍就直接完事了，此时时间复杂度是 $\Omega(n)$ ；但如果数组一开始是逆序的，那对于每个数，都得遍历一遍其左侧排序好的部分才能找到插入位置（最左侧），此时其时间复杂度是 $O(n^2)$

一些常见的函数的增长速率如下，而 n! 的增长率甚至超过指数级别

![[数算/img/img1/image-4.png]]

除此以外，还有一个平均代价的概念，这受到输入数据的可能分布的影响，比如在一个元素互不相同的数组中顺序查找某个值 k ，如果是等概率分布的，即 k 出现在数组中每个地方的位置相等，那平均代价就是 $\frac{1+n}{2}$ ；如果在各个位置出现的概率不等，则需要加权平均 

值得注意的是，在算法复杂度分析中，log 一般指以 2 为底的对数，比如二分查找就是 $O(\text{log}n)$ 的，其它数值为底时视为相同量级










