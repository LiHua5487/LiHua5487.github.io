
# 多维数组

数组：元素数量和元素类型固定的有序序列
- 静态数组：必须在定义时指定大小和类型
- 动态数组：可以在程序运行时才分配空间

多维数组：`ELEM[c1...d1]...[cn...dn]` 其中 $c_i$ 和 $d_i$ 是第 $i$ 个下标的下界和上界，可得总元素数量为 $\prod_i (d_i-c_i+1)$ 

存储方式：由于内存是一维的，所以需要把高维展平
- 行优先：先排右边的下标
- 列优先：先排左边的下标

计算一个元素的地址的基本思路是：某元素的地址 = 数组起始地址 + 该元素前面有几个元素 × 每个元素占多少地方

设各下标下界都是 0 ，一个元素长度为 $d$ ，对于二维数组 $A_{m\times n}$ ，$a_{ij}$ 的地址为

$$\text{LOC}(a_{ij})=\text{LOC}(a_{00})+(in+j)\cdot d$$

三维数组 $A_{m\times n\times p}$ ，$a_{ijk}$ 的地址为

$$\text{LOC}(a_{ijk})=\text{LOC}(a_{000})+(inp+jp+k)\cdot d$$

## 特殊矩阵

如果矩阵中的元素是有一定规律的，就不需要把每个位置的元素都存下来，而是只存“有用”的元素，把二维压缩成一维
- 对称阵：只存上 / 下三角部分
- 上 / 下三角阵：只存非 0 元素（即上 / 下三角部分，如果其余位置不是 0 ，而是同一个别的数 $w$ ，也可以这么做，此时可以把 $w$ 存到最后面）
- 稀疏矩阵：只存非 0 元素

要确定某个元素在一维数组中的哪个位置，只需要计算前面有多少个元素即可

![[数算/img/img12-1/image.png]]

![[数算/img/img12-1/image-1.png]]

对于稀疏矩阵，比较特殊，因为非 0 元素出现的位置是没有规律的，所以还要额外记录其位置，有下面几种方法
- 顺序存储：三元组表
- 链式存储：十字链表（沿着行 / 列指针一直往下走，即可访问该行 / 列的所有非 0 元素）
- 压缩表示 CSR ：采用压缩的行索引，第 $k$ 个元素代表矩阵第 $k$ 行的第一个非 0 元素在 value array 的哪个位置（其列号也可以据此找到）

![[数算/img/img12-1/image-2.png]]

![[数算/img/img12-1/image-3.png]]

![[数算/img/img12-1/image-4.png]]

## 矩阵乘法的时间代价

设 $A_{m\times p},B_{p\times n}$ ，则计算结果为 $C_{m\times n}$ 
- 采用正常存储方式，由于串行计算需要依次计算输出中的每个元素，时间复杂度为 $O(mpn)$ 
- 对于稀疏矩阵，设 $A$ 每行最多有 $t_a$ 个非 0 元素，$B$ 每列最多有 $t_b$ 个非 0 元素，则时间复杂度为 $O(m(t_a+t_b)n)$ 

![[数算/img/img12-1/image-5.png]]

# 广义表

广义表：线性表里每个元素必须是一个单蹦的东西，但是广义表里一个元素还可以是一个表（也可以是多层嵌套的表，即广义表）
- 单蹦的元素称为原子 atom ，是一个广义表的元素称为子表 sublist
- 广义表深度：嵌套了几层表（即括号层数）
- 表头：第一个元素 $x_0$ 
- 表尾：扔掉表头的表 $(x_1,\cdots,x_n)$ 

## 分类

分为线性表、纯表、再入表（可重入表）、递归表（循环表），可以用树 / 图结构来表示，重复的原子 / 子表就直接指过去

![[数算/img/img12-1/image-6.png]]

![[数算/img/img12-1/image-7.png]]

![[数算/img/img12-1/image-8.png]]

![[数算/img/img12-1/image-9.png]]

## ADT

由于广义表存在嵌套结构，用顺序表存储会很别扭，而且广义表本身就可以表示成树 / 图的形式，所以考虑链式存储

```cpp
// 元素类型标签，ATOM = 0：单元素；LIST = 1：子表
typedef enum {ATOM, LIST} TAG;
// 广义表的节点
typedef struct GLNode{
    TAG tag; // 元素类型
    union {
        ElemType data; // 一个类型为ElemType的原子
        GLNode* sublist; // 子表
    };
    GLNode* next; // 指向下一元素
};
```

其中 `union` 是一种类似于 `struct` 的东西，但是含义不同
- 一个 `union` 中，同一时刻只会存储一个成员的值，如果要存储另一个成员的值，会直接覆盖掉原先存的东西
- 所有成员共用同一块内存，内存大小由最大成员的大小决定，确保不管存谁都能存得下
- 这非常适用于广义表这种情况，因为一个元素要么是一个原子，要么是一个表，所以只用存其中一种即可

---

值得注意的是，这里我们会给每一个子表都搞一个专属的头节点，且将其标记设置为 `tag = -1` ，如果不这么做，在删除元素时会很难办

比如说 `A = ( L1:(2, 3), L2:(L1, 5) )` ，想要删除 L1 中的第一个元素 2 
- 没有头节点：那 L2 中的第一个元素（指向 L1 的指针，由于没有头节点，所以直接指向其第一个元素）就会变成悬空指针，还得调整，太麻烦了
- 有头节点：L2 的第一个元素指向 L1 的头节点，所以删了 L1 的第一个元素，仍能正常访问剩余元素

此外，还可以给每个子表搞一个 `refcount` ，记录被其它地方引用的次数，如果 `refcount` 是 0 ，那么在删除这个子表时，就毫无顾虑了；但如果要删除一个被其它地方引用的子表，就还得调整其他节点

>具体的构建方式参考 [如何画出广义表的存储结构-CSDN](https://blog.csdn.net/qq_46500711/article/details/126501497) ，这里采用了另一种 ADT ，即把 `union` 中的 `ElemType` 换为 `ElemType*` ，这样不同子表中的原子不需要重复存储；如果采用前面的那种 ADT ，如果一个原子在两个子表中的后继不同，就不能指过去（否则没法区分后继了），需要分别存储（因为后继不同，视为两个不同的节点）

# 可利用空间表

内存管理最基本的问题就是分配存储空间、回收被释放的存储空间，可以把存储器中的空闲块链接起来，形成可利用空间表 freelist 
- 使用 `new` 时，从空闲块中分配一个出去，相当于链表中删除节点，可以选择删除表头节点
- 使用 `deleta` 时，把释放的地方连接到空闲表里，相当于链表中插入节点，可以选择插入到表头

![[数算/img/img12-1/image-10.png]]

但是上面的操作都是针对于单位长度的内存块，如果要申请一片连续的内存，就需要判断空闲表里有没有这样一个地方，这里我们把一片连续的空闲块 / 占用块视为一个整体，且往往使用双链表结构来构建空闲表
- 分配：找到长度大于等于申请长度的空闲块，截取一段出来
- 回收：需要考虑释放的一片空间能不能与相邻空间合并，形成一个长度更大的空闲块

![[数算/img/img12-1/image-11.png]]

## 分配

在分配时，如果申请的长度小于空闲块的长度，有下面两种选择
- 把整个空闲块都分配出去，那在已分配的内存中，会存在一些未使用的部分，称为“内部碎片”
- 只分配实际需要的长度，那这就会剩下一个更短的空闲块，多次分配后，会出现一堆零散的短块，称为“外部碎片”

无论发生哪种情况，都会导致明明内存中有可用的部分，而且总长度可能是够的，但就是无法分配出去（要么标记为已分配，要么不连续）

空闲块的顺序适配
- 首先适配 first fit ：找到第一个满足要求的空闲块就分配
	- 分配速度快，碎片会集中在空闲表前端
- 最佳适配 best fit ：找到满足要求的最小空闲块分配
	- 减少空间浪费，但是会留下一堆很小的碎片
- 最差适配 worst fit ：找到最大的空闲块分配
	- 避免产生太小的空闲块，但是会消耗大块内存，不利于后续的大片申请
	- 比如先后申请的长度为 20 和 90 ，有长度为 30 和 100 的空闲块，如果用最差适配，分配 20 后，长度 100 的空闲块就变成 80 ，那就没法分配给 90 了

实际系统常使用首先适配的变种以提高效率

## 回收

回收时，考虑将回收部分 M 与相邻的空闲块 L 和 R 合并（对于两个相邻空闲节点，去掉右边的节点，然后将左边的长度增加）
- 检查 M 的左邻 L ，如果空闲，就将 L 的长度增加 M 
- 否则把 M 放入空闲表
- 而后检查右邻 R ，如果空闲，就把 R 删除，并将 L / M 的长度（取决于前面 L 是否空闲）增加 R 

## 失败处理策略

前面提到：明明内存中有可用的部分，而且总长度可能是够的，但就是无法分配出去，此时存储管理器可能有两种行为
- 直接返回申请失败
- 采用失败处理策略 failure policy ，把能用的地方再拼一拼

![[数算/img/img12-1/image-12.png]]

无用单元收集：最彻底的 failure policy 
- 普查内存，标记出不属于任何链的节点
- 把它们收集到空闲表中
- 回收时通常与内存压缩一起进行





