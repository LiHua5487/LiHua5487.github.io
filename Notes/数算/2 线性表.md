
# 线性表

线性表的节点
- 唯一的开始节点：无前驱，有唯一直接后继
- 唯一的终止节点：无后继，有唯一直接前驱
- 内部节点：唯一前驱和后继

一个线性表需要有以下运算
- `list()` ：创建
- `~list()` ：销毁
- 读取内容，查找内容
- 插入、删除、更改
- 判断是否为空，获取长度

线性表的存储结构
- 定长静态：一片连续的地址，支持随机访问，长度固定
- 变长动态：链式结构，使用指针关联，支持改变表的长度

## 顺序表/向量 Vector

顺序表/向量：定长的一维数组，元素类型相同

>这里的定长是指列表的 `maxSize` 是固定的，这是列表创建时预留出的长度，表示最多能让你存多少，但实际上不一定存满，实际存储的长度为 `currLen`
>在 stl 的 vector 中，如果增加元素导致长度超过当前的上限容量 capacity，会导致一次重新内存分配和数据迁移

由于一个变量存储时不知占用一个单元，所以顺序表中元素的地址会存在间隔
$$Loc(k_i)=b+L\times i$$
- $k_i$ 表示顺序表中下标为 i 的元素
- $b$ 为基地址，即表开始的地址，也是 $k_0$ 的地址
- $L$ 为偏移量，即一个元素占的内存，设其数据类型为 T ，则$L=sizeof(T)$ 

一个顺序表的代码如下

```cpp
const int Max_length = 100;

template <class T>
class arrList {
private:
	T* aList; // 顺序表开始位置的指针，代表一个表
	int maxSize;
	int curLen;
	int position; // 当前处理位置
public:
	arrList(const int size);
	~arrList();
	void clear();
	int length();
	bool append(const T value); // bool表示操作是否成功
	bool insert(const int p, const T value);
	bool delete(const int p);
	bool setValue(int p, const T value);
	bool getvalue(const int p, T &value); // 根据下标获得值
	bool getPos(int &p, const T value); // 根据值找下标
	
	arrList(const int size) { 
	    maxSize = size;
	    aList = new T[maxSize];
	    curLen = position = 0;
	}
	
	~arrList() {
	    delete [] aList;
	}
	
	void clear() {
	    delete [] aList;
	    curLen = position = 0;
	    aList = new T[maxSize];
	}
};

```

查找值的位置 `getPos` 时，可以采用简单的顺序查找，由于该元素出现在各个位置的可能性相等，所以其时间代价为 $\frac{1}{n}(1+...+n)=\frac{n+1}{2}$ ，为 $O(n)$ 

```cpp
template <class T>
bool arrList<T>::getPos(int &p, const T value) {
    for (int i = 0; i < n; i++)
        if (value == aList[i]) {
            p = i;
            return true;
        }
    return false;
}
```

对于插入元素 `insert` ，需要进行以下判断
- 有没有插入的地方（表没满）
- 插入的地方合不合法（需要与已存数据相邻，即在 $[0,currLen]$ ）
为了防止替换掉原有的数据，要先腾出空间，再插入，由于插入时需要顺序移动元素，所以时间复杂度为 $O(n)$

```cpp
template <class T>
bool arrList<T>::insert(int p, const T value) {
	if (curLen >= maxSize) // 检查剩余空间
        return false;
	if (p < 0 || p > curLen) // 检查插入位置
        return false;
    for (int i = curLen; i > p; i--)
        aList[i] = aList[i-1]; // 从后往前向后移动腾出空间
    aList[p] = value;
    curLen++; // 别忘了增加长度
    return true;
}
```

对于删除元素 `delete` ，与插入类似，需要检查
- 有没有东西能删（表非空）
- 删的地方合不合法（删的地方要有数据，即在 $[0,currLen)$ ）
删的时候从前往后向前移，时间复杂度为 $O(n)$

```cpp
template <class T>
bool arrList<T>::delete(int p) {
    if (curLen <= 0)
        return false;
    if (p < 0 || p > curLen-1)
        return false;
    for (int i = p; i < curLen-1; i++)
        aList[i] = aList[i+1];
    curLen--;
    return true;
}
```

>这个算法有个问题，就是无法改变下标为 `curLen-1` 的数据，也就是说这个位置的数据其实还在，但是由于 `currLen` 减少，导致其作废，效果上是一样的

## 链表 Linked List

链表：指针指向保持前驱关系，节点存储位置不一定相邻，可以动态申请/释放空间，允许长度变化，分为以下几类
- 单链表：只储存后继的指针，只能单向访问
- 双链表：同时储存前驱和后继的指针，能双向访问
- 循环链表：结尾的指针指向起始

下面以单链表为例，链表中的一个节点由数据域和指针域组成，长这样

```cpp
template <class T>
struct ListNode {
	T data; // 数据域，存数据
	T* next; // 指针域，存指针
};
```

整个链表的数据结构如下，其只储存头、尾指针，要想访问其中一个元素，就得从头挨个找

```cpp
template <class T>
class linkList { 
private:
	ListNode<T> *head, *tail; // 连着写都得加*才都是指针，不加的不是
	ListNode<T>* getPos(int i); // 获取下标i处的指针
public:
	// 一堆方法...
}
```

其中访问下标 i 的元素的方式如下

```cpp
template <class T>
ListNode<T> * linkList<T>::getPos(int i) {
    int count = 0;
    if (i <= -1) return head;
    ListNode<T> *p = head->next;
    while (p != NULL && count < i) {
        p = p->next;
        count++;
    };
    return p;
}
```

在链表中，通常会在开头放一个**头节点/哨兵节点 Header Node**，这是一个空节点，head 指向该节点，它起到一个辅助作用，使得对链表的第一个位置的操作和其它一致而不用更新head，同时即便链表为空也不用将 head 置空，让代码更统一

![[数算/img/img2/image-2.png]]

在下标 i 处插入时，过程如下，先让新的连后面，再让前面的连新的，需要判断
- `p == nullptr` ：插不了
- `q->next == nullptr` ：q 是尾节点，要把 tail 设为 q

![[数算/img/img2/image.png]]

在下标 i 处删除，过程如下，由于只能单向往后访问，需要获取前一个节点以更新其 next ，先连再删，需要判断
- `p == nullptr || p == tail` ：删不了
- `d == tail` ：删完后 p 是尾节点，要把 tail 设为 p ，`p->next` 设为 null

![[数算/img/img2/image-1.png]]

---

双链表额外引入了前驱的指针，其插入与删除和单节点类似

![[数算/img/img2/image-4.png]]

![[数算/img/img2/image-3.png]]

## 总结与比较

- 顺序表的主要优点
	- 没有使用指针，不用花费额外开销
	- 元素的访问更便利
- 链表的主要优点
	- 无需事先了解线性表的长度，允许长度动态变化
	- 能够适应经常插入删除内部元素的情况

- 顺序表的开销
	-  插入、删除运算时间代价 $O(n)$，查找则可常数时间完成
	-  预先申请固定长度的数组
	- 如果整个数组元素很满，则没有结构性存储开销
- 链表的开销
	- 插入、删除运算时间代价 $O(1)$，但找第 i 个元素时间代价 $O(n)$
	- 利用指针动态地按照需要为表中的元素分配存储空间
	- 每个元素都有结构性存储开销（存了指针）

可见顺序表适合存储静态数据，链表适合动态数据

## 应用

Q1 约瑟夫问题：n 个人围坐在一圆桌周围，现从第 s 个人开始报数，数到 m 的人出列，然后从出列的下一个人重新开始报数，数到 m 的人又出列，如此反复直到所有的人全部出列为止，求出列顺序

Q2 如何将仅设置了尾指针的两个循环链表合并

![[数算/img/img2/image-5.png]]

这很简单，只需要把一个的尾巴连到下一个的头，然后设一下新的尾巴

```
p = pa->next
pa->next = pb->next
pb->next = p

pa = pb // 不妨用pb作为新尾巴
```



