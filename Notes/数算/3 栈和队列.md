
# 栈

## 特性

栈 stack：限制在一端访问的线性表，后进先出（last-in-first-out LIFO），支持的操作有
- 压栈 `push` ，出栈 `pop`
- 访问栈顶 `top` ，栈底 `bottom`
- 判空 `isEmpty` ，判满 `isFull`（采用线性表的方式存储时，才有“满不满”的说法，即才需判断 `isFull`）

变种：双栈（两个对向生长的栈，支持双端入栈出栈），超栈（一端插入，两端弹出）

![[数算/img/img3/image-6.png]]

Q：假设入栈顺序为 1，2，3，4 ，判断以下出栈序列合不合法
- 1，3，4，2：可能（1入出，2入，3入出，4入出，2出）
- 1，4，2，3：不可能

Q：怎么写一个程序，根据入栈顺序，判断出栈顺序合不合法？
可以维护一个栈，按照顺序入栈，每次入栈时，对比栈顶元素和出栈元素，如果一样则出栈

>比如入栈顺序1234，判断出栈顺序1324：按照入栈顺序，1入栈，和出栈顺序比较，发现出栈第一位也是1，则1立刻出栈；而后2入栈，和出栈顺序的3（剩余部分的首位）不一样；而后3入栈，匹配，则3出栈，栈顶变为2，此时再次检查，发现2也匹配，则2也出栈；最后4入栈同理

Q：给定入栈序列，长度为 N ，怎么计算出栈顺序的种类数？

每一种出栈序列都一一对应一种入栈与出栈操作的排序，而在这一系列操作中的任意时刻，入栈次数需要不少于出栈次数，这就转化为一个经典模型：沿网格线从原点走到 $(n,n)$ ，每次都只能往上或往右走一格，且不越过 $y=x$ （即右走次数不少于上走次数），求移动方式

![[数算/img/img3/image-3.png]]

假设没有禁止触碰的限制，总走法数为 $C_{2n}^n$ ；对于越过 $y=x$ 的走法，其必与 $y = x+1$ 相交（因为在超越点一定是向上走的），把从这个交点到终点 $(n,n)$ 的路径对称过去，就会发现每条不合法的路径（等价于与 $y=x+1$ 相交），都一一对应一条从原点到 $(n-1,n+1)$ 的路径，而这个方法数是 $C_{2n}^{n-1}$ ，那么合法的走法数就是 $C_{2n}^n-C_{2n}^{n-1}$ ，也可以化简成 $\frac{1}{n+1}C_{2n}^n$

>值得一提的是，上面的结果正是**卡特兰数**，在很多场景都会见到它

## 实现方式

### 顺序栈

一种方式是用顺序表实现，把尾端作为栈顶，使用 `top` 标记（类型为 `int` ，代表对应位置下标）

```cpp
template <class T> class arrStack : public Stack <T> {
private:
    int mSize; // 栈中最多可存放的元素个数
    int top; // 栈顶位置，应小于mSize
    T* st; // 存放栈元素的数组
public:
    arrStack(int size) {
        mSize = size;
        st = new T[mSize];
        top = -1; // -1代表栈空
    }
};

```

对于各种操作，`top` 情况如下
- 入栈 `top++`
- 出栈 `top--`
- 栈空 `top == base` 或 `top == -1`
- 栈满 `top == base + stackSize` 或 `top == mSize - 1`

>如果入栈的元素存储地址变小，则称为“向下生成”的栈，但一般还是用向上的

对于栈，需要关注以下两个边界问题
- 上溢：栈都满了还要入栈
- 下溢：栈都空了还要出栈

入栈时， `top` 要先增加，再执行入栈操作

```cpp
// 需先检查栈满
top++;
st[top] = item;
```

出栈时， `top` 要先执行出栈操作，再减小

```cpp
// 需先检查栈空
item = st[top];
top--;
```

>可见我们只需更改 top ，而不用在入栈出栈时每次都分配或释放内存

### 链式栈

还可以用链表实现（单链）表，把头端作为栈顶（这样入栈出栈都能在常数时间完成）
由于我们只在栈顶，即链表头部进行操作，所以可以不使用头节点，此时栈顶指针就是链表的表头指针
由于链表没有存储空间限制，所以不用考虑栈满和上溢的问题，但仍需检查下溢（ `top == nullptr` ）

入栈和出栈与之前的链表操作类似，此处简略

```cpp
// 入栈
in = new LinkNode<T>(...);
in->next = top;
top = in;

// 出栈，需先检查栈空
out = top;
top = out->next;
free(out);
```

顺序栈与链式栈比较
- 时间效率：所有操作都只需常数时间，顺序栈和链式栈在时间效率上差不多
- 空间效率：顺序栈是固定长度，链式栈长度可变，但增加结构性开销（实际应用中，顺序栈比链式栈用得更广泛）

## 应用

### 括号匹配

对于一串嵌套的括号，如 `()(((())()))` ，检查这些括号是不是都是匹配的

可以把左括号入栈，碰到右括号则出栈，若出栈时栈空，说明右括号多了；若检测完栈内还有剩余，说明左括号多了

### DFS

深搜的思想正好与栈的操作方式契合，可以用栈来实现 DFS ，下面贴一段 python 代码，源自 AI 引论讲搜索时

```python
def dfs(graph, start, target):
    stack = [(start, [start])] # 创建栈并添加起点，元组中的列表代表路径
    visited = set() # 标记已经访问的点
    
    while stack: # 栈非空时进行搜索
        current, path = stack.pop() # 弹出栈顶元素与当前路径
        if current == target: # 到达目标就停止搜索，返回路径
            return path
        if current in visited: # 走过这个点了就跳过，避免绕圈
            continue
        visited.add(current) # 标记这个点走过了
        
        # 把相邻节点加到栈里，reversed保证顺序与添加顺序一致
        for neighbor in reversed(list(graph[current].keys())):  
            stack.append((neighbor, path + [neighbor]))
    
    return None
```

### 递归

如果把函数看作一个元素，递归调用过程就是一堆函数入栈出栈

程序运行时，系统会将内存分为几个区域，每个区域有特定的功能

![[数算/img/img3/image.png]]

- 代码区：存储程序的机器指令（即代码），用来执行，这部分是只读的，防止代码在运行时被修改
- 全局/静态区：存储全局变量和静态变量，生命周期与程序运行周期一致
- 栈：用于存储函数调用相关的数据，包括函数的局部变量和形参，由编译器自动分配和释放
- 堆 Heap ：用于动态分配的内存空间，通常通过 `malloc` `new` 等函数手动分配，并通过 `free` `delete` 手动释放
- 自由空间：堆和栈之间的区域是自由空间，供栈向下生长和堆向上生长

>在程序执行时，栈的起始位置（最上面）到堆的起始位置（最下面）这段距离是不变的，如果自由内存不够，程序可能会崩溃，而且一般栈爆了更严重

函数活动记录 Activation Record ：在程序运行过程中，每次调用一个函数，都会动态分配一块专门用于存储该函数执行状态（如参数、局部变量、返回地址等）的内存区域，每当一个函数被调用时，其活动记录会入栈；当函数执行完毕并返回时，其对应的活动记录会出栈并释放内存，其包含以下几部分
- 自变量/形参
- 用作记录信息，如返回地址（函数中调用另一个函数，等那个函数执行完，回来要继续执行哪里）
- 局部变量
- 临时变量或中间结果（比如一连串加减乘除计算）

值得注意的是，对于递归函数，对应代码运行多次，但是没有被复制多次

### 表达式求值

表达式可以分为前缀（+AB）、中缀（A+B）、后缀（AB+）表达式，对于后缀表达式，可以用栈来实现其计算

后缀表达式中不含括号，运算符放在两个参与运算的语法成分的后面，所有计算都按运算符出现的顺序从左向右进行，用栈实现就是
- 遇到操作数入栈
- 遇到运算符弹出两个操作数计算，其结果入栈
- 最后剩的那个就是表达式的结果

![[数算/img/img3/image-1.png]]

对于中缀表达式，可以转换成后缀表达式计算
- 按照运算符的优先级对所有的运算单位加括号
- 将运算符移动到对应括号的前面（前缀表达式）或后面（后缀表达式）
- 去掉括号，得到前缀或后缀表达式

>以 `31 * (5 - 22) + 70` 变为后缀运算符为例
>- 加括号： `( (31 * (5 - 22) ) + 70)`
>- 移动运算符： `((31 (5 22) - ) * 70) +`
>- 去掉括号： `31 5 22 - * 70 + ` 

而这个转换也可以用栈实现，以转换为后缀为例，从左往右看
- 是操作数，直接输出到后缀表达式序列
- 是左括号，直接入栈
- 是其它运算符，先把栈中比这个运算符优先级大的弹出去（直到栈空或碰到左括号），再入栈
- 是右括号，则弹出栈中元素直到弹出左括号（如果下溢，说明表达式有问题，括号不匹配）
- 全部读完了，若栈内仍有元素，把它们全部依次弹出，都放到后缀表达式序列尾部（若弹出的元素含有左括号，则说明括号不匹配）

![[数算/img/img3/image-2.png]]

# 队列

## 特性

队列 queue ：只能在一端删除（队头 front ），在另一端插入（队尾 rear ）的线性表，先进先出（first-in-first-out FIFO），支持以下操作
- 入队 `enqueue` ：从队尾插入元素
- 出队 `dequeue` ：从队头弹出元素
- 取队首 `getfront` ：读取队头元素
- 判空 `isempty` 

变种：双端队列（两端都能插入弹出），超队列（一端弹出，两端插入）

## 实现方式

### 顺序队列

用顺序表存储，用两个变量 `f` 和 `r` 标记队头队尾（类型为 `int` ，代表对应位置的下标），其中 `r` 指向的是待插入的位置，所以其指向的元素是空的

![[数算/img/img3/image-4.png]]

执行入队出队操作过程中，两个指针变化情况如下

![[数算/img/img3/image-5.png]]

但是这么做有个明显的问题，就是这个队列是一直往后窜的，很容易发生队尾已经到了 `maxnum` ，不能再入队了，但由于之前多次出队，前面实际上还有很多可用的空间，这种现象就叫**假溢出**

解决办法也很简单，把这个顺序表从逻辑上看成一个环就行，队空时 `f == r`，但是队满时也是这个条件，所以只能牺牲一个存储位置，用来区分队空队满，即最多存储 `maxnum - 1` 个元素，此时队满条件变为 `f == (r + 1) % maxnum` 

>如果让 r 指向队尾元素，则需要在入队时额外判断是不是队空，队空时不需要将 r + 1 ，否则要 +1 才能插入

由于设为逻辑上的循环，所以入队后需要 `r = (r + 1) % mSize` ，出队后需要 `f = (f + 1) % mSize`

### 链式队列

用单链表实现，使用两个指针 `f` 和 `r` 来标记队头队尾，判空条件为 `f == r == null`

值得注意的是，在出队时，若 `f` 更新为 null ，说明出队完事后队空，此时需要将 `r` 也设为 null

## 应用

### BFS

此处再贴一个 AI 引论的代码，寻找最短路径

```python
def bfs(graph, start, target):
    queue = deque([(start, [start])])
    visited = set()
    
    while queue:
        current, path = queue.popleft() # popleft从左端弹出
        if current == target:
            return path
        if current in visited: # 再次访问时就不是最短的了，直接跳过
            continue
        visited.add(current)
        
        for neighbor in graph[current]:
            queue.append((neighbor, path + [neighbor]))
```












