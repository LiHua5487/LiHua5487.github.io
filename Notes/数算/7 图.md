
# 基本概念

**图**：用 $G=(V,E)$ 代表，其中 $V$ 是所有顶点的集合，$\lvert V\rvert$ 为顶点个数； $E$ 是所有边的集合（不能是自己到自己），$\lvert E \rvert$ 为边的个数，图有以下分类
- 稀疏/密集图：边数相对顶点数多还是少
- 有向/无向图：边有没有方向，没方向用 $(V_1,V_2)$ ，有方向用 $<V_1,V_2>$ 
- 完全图：边的数量达到最大值
- 标号图：各顶点均带有标号
- 带权图：边上带有权重

**邻接点**：一条边连着的两个点，这条边称作与顶点**相关联的边**
**顶点的度**：与这个顶点相关联的边的数量，有向图还额外区分**入度**、**出度**（以该顶点为终点/起点），出度为 0 的顶点称为**终端节点**

如果一个图 G 有 n 个顶点，e 条边，顶点 $V_i$ 的度数为 $d_i$ ，则有以下关系

$$e=\frac{1}{2}\sum_{i=1}^n d_i$$

**子图**：把图的一些顶点及它们之间的边抠出来
**路径**：沿着边走过的顶点序列
- 简单路径：除了起点和终点可以相同，中间不能经过重复的顶点
- 回路：路径上有个环（即路径中间有两个相同顶点），把首尾顶点相同的简单路径称为简单回路
- 无环图 acyclic graph ；有向无环图 directed acyclic graph, DAG

**无向图的连通性**
- 连通图：一个无向图中，如果 $V1$ 到 $V2$ 间存在一条路径，则称它俩是连通的，如果图里任意两个顶点都是连通的，那这个图就是连通图
- 连通分量（连通分支）：一个无向图的最大连通子图

**有向图的连通性**
- 有根图：一个有向图中，若存在一个顶点 $V_0$ ，从它出发能到达所有其它顶点，那这个图就是有根图，$V_0$ 称为它的根
- 强连通性：任意两个顶点 $V_i$ 和 $V_j$ 间，均存在从 $V_i$ 到 $V_j$ 的路径，也存在从 $V_j$ 到 $V_i$ 的路径
- 强连通分量：一个有向图的最大强连通子图
- 弱连通性：只要求存在两个方向路径的其一，即将这个图视为无向图后，是连通的

网络：带权的连通图
自由树：连通的无向无环图，具有 $\lvert V \rvert -1$ 条边

如果一个无向图有 n 个顶点，e 条边，m 个环，则

$$e=n+m-1$$

# 存储结构

## 邻接矩阵

邻接矩阵（相邻矩阵）中的每个元素 $a_{ij}$ 代表从 $V_i$ 到 $V_j$ 有没有边，无则为 0 ，有则为 1 （如果带权，则设为边的权重）
- 空间代价为 $O(n^2)$ ，仅与顶点数有关
- 对角线元素全是 0 ，因为边不能从自己到自己

无向图的邻接矩阵
- 是对称阵
- 第 i 行/列的 1 的个数为 $V_i$ 的度
- 矩阵中 1 的个数的一半为总边数

有向图的邻接矩阵
- 第 i 行的 1 的个数为 $V_i$ 的出度
- 第 i 列的 1 的个数为 $V_i$ 的入度
- 矩阵中 1 的个数为总边数

对于稀疏图，它的邻接矩阵就是稀疏矩阵，可以用稀疏因子 $\delta$ 衡量其稀疏程，其定义是非零元素占总元素数的比例，若 $\delta<0.05$ ，可认为矩阵是稀疏的

## 邻接表

用一个顶点表存储所有的顶点，每个顶点还额外附带一个其邻接顶点组成的链表，称为边链表，对于无向图，由于一个边在两个顶点的位置都会存储，所以总共占用 $|V|+2|E|$ 的空间

![[数算/img/img7/image.png]]

对于有向图，分为出边表和入边表，边链表中的邻接顶点分别代表终点/起点，我们只需要选择其一进行储存即可，都能还原出图的结构，由于边是有向的，一个边只会在一个节点处存储，共占用 $|V|+|E|$ 的空间

![[数算/img/img7/image-1.png]]

当边数较少时，这种方法相比邻接矩阵能节省出很多空间，但是对于无向图，每个边都要存储两遍，这可以用邻接多重表解决；对于有向图，由于只存储出边/入边，很难确定一个顶点的度，这可以用十字链表解决

## 十字链表

维护两个链表，分别为一个顶点表和一个边表
- 顶点表：存储所有顶点，每个顶点存储其第一个入边和第一个出边
- 边表：存储所有边，每个边包含其起点与终点、起点的下一个出边、终点的下一个入边

>这里的“第一个”和“下一个”没有明确规定，只是一种逻辑上的顺序

![[数算/img/img7/image-2.png]]

那这和“十字”有啥关系呢？把顶点表中每个顶点的“入”放到一组，“出”放到一组，可以整理成下面这样

![[数算/img/img7/image-3.png]]

# 图的周游

图里可能有环，所以需要标记出已访问的节点 visited ，避免绕圈

## DFS

```cpp
void DFS(Graph& G, int V)
{
    Visit(G, V); // 从V开始访问
    G.Mark[V] = VISITED;
    for(Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e))
        if(G.Mark[G.ToVertices(e)] == UNVISITED)
            DFS(G, G.ToVertices(e)); // 递归的沿着路径走下去
}
```

![[数算/img/img7/image-4.png]]

关于时间复杂度，采用邻接表表示时，有向图总代价为 $\Theta(\lvert V \rvert + \lvert E \rvert)$ ，无向图为 $\Theta(\lvert V \rvert + 2\lvert E \rvert)$ ；采用邻接矩阵表示时，访问每个点总代价 $\Theta(\lvert V \rvert)$ 对于每个顶点 v ，DFS 需要检查所有其他顶点 u ，以确定 v 和 u 之间是否有边，总代价 $\Theta(\lvert V \rvert^2)$ ，故整体的总代价为 $\Theta(\lvert V \rvert+\lvert V\rvert^2)=\Theta(\lvert V \rvert^2)$ 

## BFS

```cpp
void BFS(Graph& G, int V){
    using std::queue;
    queue<int> Q; // 维护一队列，表示要访问它们的ToVertex
    G.Mark[V] = VISITED;
    Visit(G, V); Q.push(V);
    while(!Q.empty()) {
        int V = Q.front(); Q.pop();
        for(Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e)){
            if(G.Mark[G.ToVertex(e)] == UNVISITED) {
                G.Mark[G.ToVertex(e)] = VISITED;
                Visit(G, G.ToVertex(e));
                Q.push(G.ToVertex(e));
            }
        }
    }
}
```

![[数算/img/img7/image-5.png]]

广度优先搜索实质上与深度优先相同，只是访问顺序不同而已，故二者时间复杂度也相同

# 拓扑排序

通俗的讲，拓扑排序就是把图中的节点排成一个序列，并保证图中所有的有向边均是从左指向右的，如果把每个节点视为一个要做的事，那边就像是某种“先决条件”（必须先做什么，才能做什么）

![[数算/img/img7/image-6.png]]

- 一个图的拓扑排序是不唯一的
- 当图里有环时，就不存在拓扑序列

下面是一个基本的拓扑排序算法

![[数算/img/img7/image-7.png]]

如果采用邻接矩阵表示，那入度为 0 的点就对应着一列全是 0 ，删掉这一列及其对应的行，由于共 $\lvert V\rvert$ 个顶点，每次查找都是 $\Theta(\lvert V \rvert)^2$ ，所以总时间复杂度为 $\Theta(\lvert V \rvert)^3$ 

## BFS-Top Sort

如果采用邻接表表示，可以给每个节点附带一个入度信息，构成一个入度表，可以利用 BFS 去实现这个循环过程

```cpp
void TopsortbyQueue(Graph& G) {
    for(int i = 0; i < G.VerticesNum(); i++)
        G.Mark[i] = UNVISITED;
    using std::queue;
    queue<int> Q;
    
    // 把所有入度为0的节点入队
    for(i = 0; i < G.VerticesNum(); i++) {
        if(G.Indegree[i] == 0)
            Q.enqueue(i);
    }
    
    while(!Q.empty()){
        V = Q.dequeue();
        Visit(G, V); // 标为Visited代表删除节点
        // 边的终点的入度值减1，如果入度变为0就入队
        for(Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e)) {
            G.Indegree[G.ToVertex(e)]--;
            if(G.Indegree[G.ToVertex(e)] == 0)
                Q.enqueue(G.ToVertex(e));
        }
    }
    
    // 检测有没有节点未被访问
    for(i = 0; i < G.VerticesNum(); i++) {
        if(G.Mark[i] == UNVISITED){
            Print("图有环");
            break;
        }
    }
}
```

当图中存在环时，由于无论怎么删节点，环上的节点入度都至少为 1 ，那这些点就不会被标记为 visited ，所以只需判断有没有 unvisited 的节点就能判断有没有环

采用邻接表时 ，因为整了个入度表，所以查找入度为 0 的节点只需 $\Theta(\lvert V \rvert)$ 的时间，加上处理边、顶点的时间，总代价为 $\Theta(2\lvert V \rvert + \lvert E \rvert)$ 

## DFS-Top Sort

也可以用 DFS ，但此时得到的序列是逆序的，即箭头是从右往左指的

```cpp
void TopsortbyDFS(Graph& G){
    for(int i = 0; i < G.VerticesNum(); i++)
        G.Mark[i] = UNVISITED;
    int *result = new int[G.VerticesNum()];
    int tag = 0;
    // 遍历每个节点，若未访问就递归调用Do_topsort访问下去
    for(i = 0; i < G.VerticesNum(); i++)
        if(G.Mark[i] == UNVISITED)
            Do_topsort(G, i, result, tag);
    // 逆序输出
    for(i = G.VerticesNum() - 1; i >= 0; i--) {
        Visit(G, result[i]);
    }
}

void Do_topsort(Graph& G, int V, int *result, int &tag){
    G.Mark[V] = VISITED;
    // 访问V邻接的所有未被访问的顶点
    for(Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e))
        if(G.Mark[G.ToVertex(e)] == UNVISITED)
            Do_topsort(G, G.ToVertex(e), result, tag); // 递归调用
    result[tag++] = V;
}

```

但是由于 DFS 维护了一个 visited 列表防止绕圈，使其能访问到图中的所有顶点，这就无法判断有没有环存在，比如下面这种情况，即便有环，也会给出一个序列，尽管这个序列并不是拓扑序列

![[数算/img/img7/image-8.png]]

而 BFS 中，由于这里没有入度为 0 的节点，所以算法从一开始就终止了，这仨节点都访问不到

# 最短路径问题

要在带权图上找到两个节点间的最小权重路径，如果所有边的权重都一样，那直接用 BFS 就行，但更多的情况是权重不一样

## Dijkstra 算法

适用于单源最短路径问题，即给定一个节点 s ，找到其到其它各个节点的最短路径
- 基本思想：维护一个子图，我们知道在这个子图内部， s 到其它节点的最短路径；逐渐去扩充这个子图，每次加入一个节点，优先选择与子图内的节点有边直接相连的那些
- 其本质是一类贪心算法，只适用于边权非负的情况

比如以下这个图，取 $s=v_1$ ，我们给图中每个节点额外储存一个值，代表当前为止 $v_1$ 到其的最短路径长度，若没有与子图中的节点直接相连，则设为 $\infty$ ；并且我们把子图中的节点标记为黄色

![[数算/img/img7/image-9.png]]

于是一开始这些值是这样的，且只有 $v_1$ 在子图中，$v_2$ $v_3$ $v_4$ 与其直接相连，值为边权，剩下节点没有直接相连，全是 $\infty$ 

![[数算/img/img7/image-10.png]]

由于 $v_4$ 离得最近（所有顶点的值中最小），所以将 $v_4$ 加入子图，此时 $v_7$ 与其直接相连，更新其值为：$v_1\rightarrow v_4$ 的最短路径长度（即 $v_4$ 处的值）+ $v_4\rightarrow v_7$ 的边权 

![[数算/img/img7/image-11.png]]

而后加入 $v_2$ ，其与 $v_3$ 和 $v_5$ 相连，更新它们的值，由于 $v_1\rightarrow v_2\rightarrow v_3$ 和 $v_1\rightarrow v_3$ 的权重一样，所以值没有变化

![[数算/img/img7/image-12.png]]

重复这个过程，最后把所有点都加入子图，每个顶点的值就是 $v_1$ 到其的最短路径长度

![[数算/img/img7/image-13.png]]

实际上，我们可以抽象成以下数据结构：维护一个列表，每个元素对应一个顶点，储存其到 s 的最短路径长度，及其前驱（入边相连的那些点），并标记出哪些顶点在子图中（下图红色部分，而蓝色部分代表与子图直接相连）


![[数算/img/img7/image-14.png]]

注意到，我们需要在这个列表中查找最小值，如果直接遍历查找，每次寻找权值最小节点，需要进行 $|V|$ 次扫描，每次扫描 $|V|$ 个节点（$|V|^2$），而在更新D值处总共扫描 $|E|$ 次，总时间复杂度为 $\Theta(|V|^2 + |E|) = \Theta(|V|^2)$ 

如果采用最小堆的方式，每次改变路径长度信息
- 通过先删除再重新插入的方法来改变顶点 $i$ 在堆中的位置
- 或者仅为某个顶点添加一个新值，而不作删除操作，因为旧值被找到时，该顶点一定被标记为 visited ，从而被忽略
- 不作删除旧值的缺点是，在最差情况下，将使堆中元素数目增加到 $\Theta(|V|)$ ，此时总的时间复杂度为 $\Theta((|V| + |E|)\log |E|)$ ，因为处理每条边时都必须对堆进行一次重排

## Floyd 算法

要求图中任意两点间的最短路径，如果对每个顶点作为 s 并执行 Dijkstra 算法，这显然太冗余了

Floyd 算法的想法是，用邻接矩阵 adj 表示一个图（值为边权，无边相连则为 $\infty$ ），逐渐迭代这个矩阵，记第 k 次迭代后的矩阵为 $adj^{(k)}$ ，$adj^{(k)}[i,j]$ 的含义是从 $v_i$ 到 $v_j$ ，只考虑 $v_1 \cdots v_k$ 作为可选的中间节点的最短路径的长度（即在 $v_i$ $v_j$ 和 $v_1 \cdots v_k$ 构成的子图上的最短路径长度）

下面考虑递推公式，假设已经求得 $adj^{(k-1)}$ ，要求 $adj^{(k)}$ ，相当于额外引入 $v_k$ 作为可选的中间节点，此时从 $v_i$ 到 $v_j$ 的最短路径有两种情况
- 若最短路径不经过 $v_k$ ，则 $adj^{(k)}[i,j]=adj^{(k-1)}[i,j]$ 
- 若最短路径经过 $v_k$ ，则说明 $adj^{(k)}[i,j]<adj^{(k-1)}[i,j]$ ，且 $adj^{(k)}[i,j]=adj^{(k-1)}[i,k]+adj^{(k-1)}[k,j]$ 

这就可以利用动态规划去实现

![[数算/img/img7/image-15.png]]

那怎么记录最短路径呢？可以维护一个 path 矩阵，$path[i,j]$ 表示从 $v_i$ 到 $v_j$ 的最短路径上，在 $v_j$ 前面的那个节点的序号，如果没有最短路径，就设为 -1 
- 在迭代更新时，如果最短路径经过了 $v_k$ ，则 $path[i,j]=path[k,j]$ 
- 在查找两点间最短路径时，只需递归的进行，比如查找 $path[i,j]=v_p$ ，继续查找 $path[i,p]=\cdots$ 

![[数算/img/img7/image-16.png]]

由于要迭代 $|V|$ 次，每次更新矩阵中 $|V|^2$ 个元素，总时间复杂度为 $O(n^3)$

# 最小支撑（生成）树 MST

最小支撑树：对于一个带权连通无向图，在保证连通性的前提下，尽可能删边，使得边权总和最小，得到的结果就是最小支撑树（这个结果无环，看起来像个树）

## Prim 算法

- 从任一顶点开始，把它加入 MST 里
- 考察与 MST 中节点直接相连的那些顶点，把权重最小边连接的顶点加进去
- 直到所有顶点都被加到 MST 里，选择不同顶点开始，得到的结果可能不唯一，但最小权值总和是确定的

![[数算/img/img7/image-17.png]]

```cpp
void Prim(Graph& G, int start, Edge* &MST) {
    int MSTTag=0; // 当前MST的节点数
    Edge* MST=new Edge[G.VerticesNum()-1];
    MinHeap<Edge> H(G.EdgesNum()); // 用最小堆，便于找到权最小的边
    for(int i=0;i<G.VerticesNum();i++)
        G.Mark[i]=UNVISITED; // 标记有没有访问过，即在不在MST里

    int v=start;
    G.Mark[v]=VISITED;
    do {
	    // 把v连接的边都加到最小堆
        for(Edge e=G.FirstEdge(v);G.IsEdge(e);e=G.NextEdge(e))
            if(G.Mark[G.ToVertex(e)]==UNVISITED)
                H.Insert(e);
        // 找到权最小的边
        bool Found=false;
        while(!H.empty()) {
            e=H.RemoveMin();
            // 边连接的顶点不在MST里，就需要把它加进来
            if(G.Mark[G.ToVertex(e)]==UNVISITED){
                Found=true;
                break;
            }
        }
        // 边连接的点都在MST里，但是又没有涵盖所有顶点，说明图不是连通的
        if(!Found){
            Print("不存在线最小支撑树"); 
            delete [] MST;
            MST=NULL;
            return;
        }
        // 把边连接的点加到MST，并转移到这个点
        v= G.ToVertex(e);
        G.Mark[v]=VISITED;
        AddEdgetoMST(e,MST,MSTTag++);
    } while(MSTTag < (G.VerticesNum()-1))
}
```

如何证明这种方法得到的结果就是权值总和最小的呢？这里有一个**切割性质**：把一个带权连通无向图切割为两部分 $P$ 和 $Q$ ，考虑一端连接 $P$ 中顶点、一端连接 $Q$ 中顶点的那些边，其中权值最短的边 $e$ 一定在某个 MST 中

这个性质可以利用反证法证明：如果 $e$ 所在树 $T$ 不是 MST ，考虑到图的连通性，必须有另一个连接 $P$ 和 $Q$ 的边 $e'$ 在一个 MST  $T'$ 里，但是 $e'$ 的权大于等于 $e$ 
- 如果 $w(e')>w(e)$ ，则 $T'$ 边权总和大于 $T$ ，那 $T'$ 就不是 MST ，矛盾
- 如果 $w(e')>w(e)$ ，则 $T'$ 边权总和等于 $T$ ，而 $T'$ 是 MST ，则 $T$ 也是 MST ，但是我们先前假设 $e$ 所在树 $T$ 不是 MST ，矛盾

假设我们使用 Prim 算法构建出的树 $T$ 不是 MST ，则存在一个 MST $T'$ 使得 $w(T')<w(T)$ ，考虑 Prim 算法的建树过程，由切割性质，每一步选择的边 $e_i$ 一定在某个 MST 里，但是我们不知道这些 $e_i$ 是不是在同一个 MST 里

假设 $e_1\cdots e_{k-1}$ 都在 $T'$ 里，而 $e_k$ 是第一个不在 $T'$ 里的边，到这一步时处在 Prim 树中的节点记为 $S$ ，剩下的记为 $V-S$ ，考虑到连通性，$T'$ 中一定会有另一个连接 $S$ 和 $V-S$ 的边 $f$ ，且 $w(f)\geq w(e_k)$ ，如果我们把 $T'$ 中的 $f$ 删了而把 $e_k$ 加进去得到 $T''$ ，这并不影响连通性，但是 $w(T'')\leq w(T')$ 
- 如果 $w(T'')< w(T')$ ，那 $T'$ 就不是 MST ，矛盾
- 如果 $w(T'')= w(T')$，那 $e_1\cdots e_k$ 就都在另一个 MST $T''$ 中，考察 $e_{k+1}$ ，也可以得到类似的结果，递推可得 $T$ 中所有边 $e_1\cdots e_n$ 一定在某个 MST 里，而 $e_1\cdots e_n$ 构成的树就是 $T$ ，这说明 $T$ 就是 MST 

Prim 算法与 Dijkstra 算法类似，都是贪心的思路，但是 Prim 算法是把距离已加入的顶点最近的点加进来，而 Dijkstra 算法是把距离源点最近的点加进来；二者时间复杂度相同

## Kruskal 算法

- 初始时，把每个顶点都视为一个等价类
- 按照边权从小到达的顺序处理，如果一条边连接两个不同等价类，则将边加入 MST ，并把两个等价类合并
- 直到最后剩下一个等价类，如果处理完所有边但是存在多个等价类，说明图不连通

```cpp
void Kruskal(Graph& G, Edge* &MST) {
    Partree A(G.VerticesNum());
    MinHeap<Edge> H(G.EdgesNum());
    MST=new Edge[G.VerticesNum()-1];
    int MSTTag=0;
    // 把图中所有边放到最小堆里
    for(int i=0; i<G.VerticesNum(); i++) {
        for(Edge e=G.FirstEdge(i); G.IsEdge(e); e=G.NextEdge(e))
            if(G.FromVertex(e)<G.ToVertex(e))
                H.Insert(e);
    }
    int EquNum=G.VerticesNum(); // 等价类的数量
    while(EquNum>1) {
        Edge e=H.RemoveMin(); // 取权值最小的边
        int from=G.FromVertex(e);
        int to= G.ToVertex(e);
        // 不是同一个等价类就合并
        if(A.differ(from,to)) {
            A.UNION(from,to);
            AddEdgetoMST(e,MST,MSTTag++);
            EquNum--;
        }
    }
}
```

建堆时间复杂度 $O(\lvert E\rvert)$ ，遍历时共处理 $\lvert E\rvert$ 个边，取权值最小的边时需要在最小堆中删除，为 $O(\log \lvert E\rvert)$ ，而等价类的 `differ` 与 `union` 都是常数时间，所以总时间复杂度为 $O(\lvert E\rvert+\lvert E\rvert \log \lvert E\rvert)=O(\lvert E\rvert \log \lvert E\rvert)$ ，可见其适合稀疏图











