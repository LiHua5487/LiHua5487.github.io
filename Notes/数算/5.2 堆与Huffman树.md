
# 堆

堆是一种特殊的完全二叉树，分为两类
- **最大堆（Max-Heap）**：任意节点的值都大于等于其子节点的值，即根节点是整个堆的最大值
- **最小堆（Min-Heap）**：任意节点的值都小于等于其子节点的值，即根节点是整个堆的最小值

![[数算/img/img52/image.png]]

同一关键码使用不同方法构建出的堆可能互不相同，因为堆并不对兄弟节点的大小进行限制，只限制了根节点和子树的节点的大小关系

由于堆是完全二叉树，所以可以直接根据某个节点的下标 $i$ 来获取其左子、右子、父节点的下标

下面以最小堆为例，说明堆的构建、插入节点和删除节点的方法

## 构建

先从一个简单的情况考虑，假设一个根节点的左子树和右子树已经是最小堆了，但是根节点至少大于其中一个子节点，此时可以把根节点与两个子节点中较小者交换位置，而后考察根节点交换后的位置对应的左右子节点是不是都比根节点大，递归的进行下去，这种方法称为“向下筛选”

```cpp
template<class T>
void MinHeap<T>::SiftDown(int position) {
    int i = position;  // 父节点下标
    int j = 2 * i + 1; // 值较小的子节点，初始化为左子节点
    T temp = heapArray[i]; // 用于交换节点
    while (j < CurrentSize) {
        if ((j < CurrentSize - 1) && (heapArray[j] > heapArray[j + 1])) // 如果左子节点比右子节点大
            j++; // 指向右子节点
        if (temp > heapArray[j]) { // 父节点比某个子节点大
            heapArray[i] = heapArray[j];
            i = j; // 指向父节点交换后的位置
            j = 2 * j + 1; // 移动到交换后的位置的左子节点
        } else break;
    }
    heapArray[i] = temp;
}
```

下面考虑一般情况，给定关键码序列 `[5, 3, 8, 1, 2, 6]` ，想要构建一个最小堆，我们可以先构建一个完全二叉树，这很简单，只需要依次把序列中的元素从上到下、从左到右的放到完全二叉树的相应位置即可

```
.       5
.     /   \
.    3     8
.   / \   /
.  1   2 6
```

可以发现，叶节点本身肯定是一个最小堆（因为只有这一个节点），所以我们从倒数第二层开始，从右往左、从下往上的按照上述方法对每个节点进行调整，最先考察 8 ，发现其比 6 大，那就交换一下

```
.       5
.     /   \
.    3     6
.   / \   /
.  1   2 8
```

而后考察 3 发现比 1 和 2 都大，其中 1 最小，那就把 3 和 1 交换

```
.       5
.     /   \
.    1     6
.   / \   /
.  3   2 8
```

最后考察 5 ，发现比 1 大，就和 1 交换

```
.       1
.     /   \
.    5     6
.   / \   /
.  3   2 8
```

换完了发现其比 3 和 2 都大，还要再和 2 换，就得到了最终结果

```
.       1
.     /   \
.    2     6
.   / \   /
.  3   5 8
```

代码中只需要依次对每个位置调用上面的筛选算法即可

```cpp
template<class T>
void MinHeap<T>::BuildHeap() {
    for (int i = CurrentSize/2 - 1; i >= 0; i--)
        SiftDown(i);
}
```

## 插入

插入时，先放到最后面的位置，而后与父节点比较比较并逐层向上交换，这称为“向上筛选”

```cpp
template<class T>
void MinHeap<T>::SiftUp(int position) {
    int temppos = position;
    T temp = heapArray[temppos];
    while ((temppos > 0) && (heapArray[parent(temppos)] > temp)) {
        heapArray[temppos] = heapArray[parent(temppos)];
        temppos = parent(temppos);
    }
    heapArray[temppos] = temp;
}

template<class T>
bool MinHeap<T>::Insert(const T& newNode) {
    if (CurrentSize == MaxSize)
        return FALSE;
    heapArray[CurrentSize] = newNode;
    SiftUp(CurrentSize);
    CurrentSize++;
}
```

## 删除

在删除时，把待删除的节点先和整个树的最后一个节点交换位置，再把最后一个节点（即原先的待删除节点）删除，而对于原先待删除节点所处的位置，需要分别进行向上和向下筛选，以保证删除后仍是最小堆（如果删除的是整个树的根节点，则只需向下筛选）

```cpp
// 删除最小元素，即整个树的根节点
template<T> T& MinHeap<T>::RemoveMin() {
    if (CurrentSize == 0) {
        return -1; // 空堆，删不了
    } else {
        swap(0, CurrentSize--);
        if (CurrentSize > 1) 
            SiftDown(0);
        return heapArray[CurrentSize];
    }
}

// 删除任一节点
template<class T>
bool MinHeap<T>::Remove(int pos, T& node) {
    if ((pos < 0) || (pos >= CurrentSize))
        return false;
    T temp = heapArray[pos];
    heapArray[pos] = heapArray[--CurrentSize];
    SiftUp(pos);
    SiftDown(pos);
    node = temp;
    return true;
}

```

但实际上，对于向上和向下筛选中，至多只有一个是有效的，因为如果进行了向上筛选，那交换过来的数肯定是比子树要更小的（因为其原先处在更上层），就不需要再进行向下筛选了，所以可以进一步优化

```cpp
// 实际上更高效的实现可以是：
if (pos > 0 && heapArray[pos] < heapArray[(pos-1)/2]) {
    SiftUp(pos);
} else {
    SiftDown(pos);
}
```

## 时间复杂度分析

n个结点堆的高度为 $\log n$ $，第$ $i$ 层上的结点数最多为 $2^i$ ，建堆过程中，每个非叶子结点都调用一次向下筛选算法，而每次最多向下调整到最底层，即第 $i$ 层上的结点向下调整到最底层的调整次数为 $\log n - i$ ，则建堆的计算时间为

$$
\sum_{i=0}^{\log n} 2^i \cdot (\log n - i)
$$

令 $j = \log n - i$ ，代入上述式得

$$
\sum_{i=0}^{\log n} 2^i \cdot (\log n - i) = \sum_{j=0}^{\log n} 2^{\log n - j} \cdot j = \sum_{j=0}^{\log n} n \cdot \frac{j}{2^j} < 2n
$$

即建堆算法的时间复杂度是 $O(n)$

由于堆有 $\log n$ 层深，插入结点、删除普通元素和删除最小元素的平均时间代价和最差时间代价都是 $O(\log n)$

## 优先队列

优先队列 priority queue 中每个元素有一个关键码值，其主要特点是能快速地查找并移出具有最大值或最小值的元素，分为两种，可见堆是优先队列的一种自然的实现方法
- 最小优先队列，适合查找和删除最小元素
- 最大优先队列，适合查找和删除最大元素

# Huffman 树

考虑一种对外部节点进行加权的扩充二叉树，设其共有 n 个外部节点，每个外部节点对应一个权重值 $w_i$ ，计算外部路径长度和时，根据到达的外部节点进行加权求和

$$WPL=\sum_{i=0}^{n-1}w_iL_i$$

![[数算/img/img52/image-1.png]]

在这若干种树的构建方式中，WPL 最小的一个就是 Huffman 树，也称最优二叉树，可见其倾向于把权重高的外部节点放在更浅的地方

给定一系列节点的权重值，构建 Huffman 二叉树的方法如下，每次从中取出值最小的两个节点，把它们分别作为左子树和右子树，根节点的值记为二者的值的和，把这个值放回序列中，其对应着上述根节点及其子树结构，重复上述过程

![[数算/img/img52/image-2.png]]

在代码实现时，可以采用最小值堆来维护这个序列

```cpp
// Huffman 树类
template <class T> class HuffmanTree {
private:
    HuffmanTreeNode<T>* root;
    // 把ht1和ht2为根的合并成一棵以parent为根的Huffman子树
    void MergeTree(HuffmanTreeNode<T> &ht1, 
                   HuffmanTreeNode<T> &ht2, HuffmanTreeNode<T>* parent);

public:
    HuffmanTree(T weight[], int n);
    virtual ~HuffmanTree() { DeleteTree(root); }
};

// 建树
template<class T>
HuffmanTree<T>::HuffmanTree(T weight[], int n) {
    MinHeap<HuffmanTreeNode<T>> heap;
    HuffmanTreeNode<T>* parent, &leftchild, &rightchild;
    HuffmanTreeNode<T>* NodeList = new HuffmanTreeNode<T>[n];
	
	// 初始化最小堆
    for (int i = 0; i < n; i++) {
        NodeList[i].element = weight[i];
        NodeList[i].parent = NodeList[i].left 
                          = NodeList[i].right = NULL;
        heap.Insert(NodeList[i]);
    }
	
	// 循环建树
    for (i = 0; i < n-1; i++) {
        parent = new HuffmanTreeNode<T>;
        // 取俩最小值
        firstchild = heap.RemoveMin();
        secondchild = heap.RemoveMin();
        // 合并
        MergeTree(firstchild, secondchild, parent);
        // 放回去
        heap.Insert(*parent);
        root = parent;
    }

    delete [] NodeList;
}

```

这种方法初始建堆时间为 $O(n)$ ，构建 Huffman 树过程中进行了 n-1 次插入，每次插入时间复杂度为 $O(\text{log}n)$ ，故总时间复杂度为 $O(n+(n-1)\text{log}n)=O(n\log n)$ 

---

那 Huffman 树有啥用呢？在对每个英文字母进行编码时，一个最直接的方法是采用一个固定位数的二进制数，把每个字母都映射到一串 0 1 组合，这种方式属于等长编码

但是实际上，不同字母的使用频率是不同的，为了节省空间，我们希望让使用频率更高的字母的编码更短一些，而不常出现的字母相对较长，这正好与 Huffman 树的特点相契合

可以从一个语料库中统计各个字母的出现次数，将其视为这个字母的权重值，据此构建一个 Huffman 树，其中每个外部节点就对应一个字母，在编码时，考察从根节点到这个字母对应的外部节点的路径，往左分支走一次就在后边加个 0 ，往右分支走一次就在后边加个 1 ，具体参考以下例子

![[数算/img/img52/image-4.png]]

![[数算/img/img52/image-3.png]]

这种编码方式还具有一个很好的性质，就是不存在一个字母的编码是另一个字母的编码的前缀的情况，因为每个字母都是叶节点，这就可以避免编码序列的分割方式不同造成的二义性














