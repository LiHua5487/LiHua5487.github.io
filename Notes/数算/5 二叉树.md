
# 概念与性质

## 分类

**二叉树**：从一个根节点出发，每个节点最多有两个分叉

层数：根节点层数为 0 ，后续每个节点等于其父节点层数 +1 

度数：一个节点的分叉数

**满二叉树**：所有节点要么没分叉，要么有 2 个分叉（1 度节点数量为 0 ）

**完全二叉树**：叶节点只能在最下面 2 层出现；最下面一层的节点从左往右连续排列

![[数算/img/img5/image.png]]

- 完全二叉树不一定是满二叉树
- 具有同样数量的节点的二叉树中，完全二叉树从根节点到叶节点的路径最短

**扩充二叉树**：通过增加空的节点，把所有节点的度数扩充到 2 ，扩充的节点称为外部节点，原来就有的节点称为内部节点

![[数算/img/img5/image-1.png]]

- 扩充二叉树是满二叉树
- 外部节点数 = 内部节点数 + 1
- 若内部节点数量为 $n$ ，定义外部长度和 $E$ 为根节点到所有外部节点的长度和，内部长度和 $I$ 为根节点到所有内部节点的长度和，则满足

$$E=I+2n$$

## 基本性质

1. 二叉树第 i 层上最多有 $2^i$ 个节点
2. 深度为 k 的二叉树最多有 $2^{k+1}-1$ 个节点，最少有 $k+1$ 个节点
3. 具有 n 个节点的完全二叉树深度为 $\lfloor \text{log}_2n\rfloor$ 
4. 对于非空二叉树，叶节点数量为 $n_0$ ，度数为 2 的节点数量为 $n_2$ ，则$n_0=n_2+1$ 
5. 对于具有 n 个节点的完全二叉树，如果从上到下从左到右对树中的所有节点从 0 开始进行编号，则对于序号为 i 的节点，有
	- 若 $i>0$ ，则其父节点序号为 $\lfloor (i-1)/2 \rfloor$ （$i=0$ 则为根节点）
	- 若 $2i+1 \leq n-1$ ，则其左子节点序号为 $2i+1$ ，否则无左子节点
	- 若 $2i+2 \leq n-1$ ，则其右子节点序号为 $2i+2$ ，否则无右子节点

---

关于 3 的证明：设度数为 1 的节点数量为 $n_1$ ，则总节点数为 

$$n=n_0+n_1+n_2$$

设边的数量（分叉的数量）为 B ，由于每个节点只有一个前驱（上面只连一根线），根节点没有前驱，所以

$$B=n-1$$

另一方面，每个边又是由节点发出的，则

$$B=n_1+2\cdot n_2$$

那么就可得

$$n_0=n_2+1$$

有了这个结论，前面扩充二叉树的性质 “外部节点数 = 内部节点数 + 1” 就很好证明了：扩充后叶节点就是所有的外部节点，而扩充后变为满二叉树，所以内部节点的度数全变为 2 

这还可以得到推论：非空满二叉树中，叶节点数 = 分支节点数 + 1

---

关于扩充二叉树 $E=I+2n$ 的证明：用归纳法，显然 $n=1$ 时，$I=0$ ,$E=1+1=2$ ，此式成立

假设 n 个内部节点的二叉树满足 $E_n=I_n+2n$ ，现考虑 $n+1$ 个内部节点，我们扣掉一个在扩充前为叶节点的节点，设其内部路径长度为 K ，则扣掉后内部路径和变为

$$I_n'=I_{n+1}-K$$

对于外部路径和，少了根节点到这个节点扩充的两个节点的路径，这个长度是 $K+1$ ，而扣掉后，这个节点的位置被扩充的空节点取代，多出了到这个节点的路径，这个长度是 $K$ ，则外部路径和变为

$$E_n'=E_{n+1}-2\cdot(K+1)+K=E_{n+1}-K-2$$

那么对于 n+1 个内部节点的二叉树，满足

$$E_{n+1}=E_n'+K+2=(I_n'+2n)+K+2=I_{n+1}+2(n+1)\quad \blacksquare$$

# 二叉树的周游/遍历

## DFS

深度优先：一条道走到黑，到底了再退回去走别的分叉，时间和空间复杂度均为 $O(n)$ ，可以按照访问顺序（递归的访问）分为以下类型
- 前序周游：根节点 → 左子树 → 右子树
- 中序周游：左子树 → 根节点 → 右子树
- 后序周游：左子树 → 右子树 → 根节点

![[数算/img/img5/image-2.png]]

>可见前中后指的是在一个递归过程中啥时候访问该节点，而且前中后序周游的根节点分别在整个二叉树的访问序列中的前中后

对于中序周游，有一个 trick 来得出其遍历顺序

![[数算/img/img5/image-3.png]]

值得注意的是，无论哪种遍历方式，叶节点的访问顺序是相同的，因为都是先左子树后右子树

---

单独的依靠某个访问序列，并不能恢复出二叉树，考虑依靠其中二者的组合
- 前序 + 中序：可以唯一确定二叉树
	原因：前序序列的第一个节点是根节点，在中序序列中找到根节点后，根节点左侧是左子树的中序，右侧是右子树的中序，递归应用此过程，可以重建整个二叉树
- 后序 + 中序：可以唯一确定二叉树
	原因：后序序列的最后一个节点是根节点，在中序序列中找到根节点后，根节点左侧是左子树的中序，右侧是右子树的中序，递归应用此过程，可以重建整个二叉树
- 前序 + 后序：通常不能唯一确定二叉树，除非二叉树是满二叉树
	反例：考虑两个不同的二叉树
    - 二叉树1：根节点A，左孩子B
    - 二叉树2：根节点A，右孩子B
    两个二叉树的前序序列均为 AB ，后序序列均为 BA ，但中序序列不同（二叉树1为 BA ，二叉树2为 AB ），因此，仅凭前序和后序无法区分这两种结构

以前面的图中的二叉树为例，中序是 DGBAECHF ，后序是 GDBEHFCA
- 先根据后序确定根节点，即后序的最后一个节点，可得根节点为 A 
- 在中序找到 A ，前后分为两半，代表其左右子树，可得左子树中序 DGB ，右子树中序 ECHF
- 对这两个子树重复上面过程，以左子树为例，其中序为 DGB ，在后序中找到对应序列，为 GDB ，根节点为 B ，则 B 的左子树中序为 DG ，无右子树

---

对于深搜，可以用递归和非递归的方法实现，递归方法如下

```cpp
template<class T>
void BinaryTree<T>::DepthOrder (BinaryTreeNode<T>* root) {
    if(root != NULL) {
        Visit(root);                      // 前序
        DepthOrder(root->leftchild());    // 递归访问左子树
        Visit(root);                      // 中序
        DepthOrder(root->rightchild());   // 递归访问右子树
        Visit(root);                      // 后序
    }
}
```

对于非递归的方式，可以用栈去模拟，前序遍历实现如下，正常情况下，`while` 循环条件应该是 `!aStack.empty() || pointer` ，表示如果栈非空或当前访问的指针 `pointer` 非空，就需要继续遍历

这里使用了监视哨（栈底放一个空指针），这样循环条件中只需判断当前访问的指针是不是空的，而不需要额外判栈空

```cpp
template<class T>
void BinaryTree<T>::PreOrder (BinaryTreeNode<T>* root) {
    using std::stack;
    stack<BinaryTreeNode<T>*> aStack;           
    BinaryTreeNode<T>* pointer = root;
    aStack.push(NULL); // 监视哨 
    while(pointer) {                            
        Visit(pointer); // 先访问根节点
        // 由于栈后进先出，所以先放右子树，再放左子树
        if (pointer->rightchild() != NULL)
            aStack.push(pointer->rightchild());
        if (pointer->leftchild() != NULL)
            pointer = pointer->leftchild();
        else {
	        pointer = aStack.top();
	        aStack.pop();
	    }
    }
}
```

当然也可以不采用监视哨，这与下面的中序实现方式更一致

```cpp
template<class T>
void BinaryTree<T>::PreOrder (BinaryTreeNode<T>* root) {
    using std::stack;
	stack<BinaryTreeNode<T>*> aStack;
	BinaryTreeNode<T>* pointer = root;
	
	while(pointer || !aStack.empty()) {
		if (pointer) {
			Visit(pointer); // 先访问根节点
			aStack.push(pointer); // 存入根节点以便获取其右子树
			pointer = pointer->leftchild(); // 转移到左子树
		} else {
			pointer = aStack.top(); // 获取上层的根节点
			aStack.pop();
			pointer = pointer->rightchild(); // 转移到右子树
		}
	}
}
```

对于中序遍历，只需简单调整

```cpp
template<class T>
void BinaryTree<T>::InOrder (BinaryTreeNode<T>* root) {
    using std::stack;
    stack<BinaryTreeNode<T>*> aStack;
    BinaryTreeNode<T>* pointer = root;
    while (!aStack.empty() || pointer) {
        if (pointer) {
            aStack.push(pointer);
            pointer = pointer->leftchild(); // 转移到左子树
        }
        else {
            pointer = aStack.top();
	        aStack.pop();
            Visit(pointer); // 访问根节点
            pointer = pointer->rightchild(); // 转移到右子树
        }
    }
}
```

对于后序遍历，需要在一个节点的左子树和右子树访问完了之后才能访问这个节点，为此，给每个节点 P 打上一个标签 L/R ，入栈时代表正在访问其左/右子树，出栈时表示访问完了，在 $(P,L)$ 出栈后，将 P 的标签改为 R ，在 $(P,R)$ 也出栈后，就可以访问 P 

```cpp
enum Tags { Left, Right };

template <class T>
struct StackElement { // 带标签的节点
    BinaryTreeNode<T>* pointer;
    Tags tag;
};
```

```cpp
template<class T>
void BinaryTree<T>::PostOrder(BinaryTreeNode<T>* root) {
    using std::stack;
    StackElement<T> element;
    stack<StackElement<T>> aStack;
    BinaryTreeNode<T>* pointer;
    pointer = root;

    while (!aStack.empty() || pointer) {
        if (pointer != NULL) { // 先访问左子树
	        // 标签设为Left并入栈
            element.pointer = pointer; 
            element.tag = Tags::Left;
            aStack.push(element);
            // 移到左子树
            pointer = pointer->leftchild();
        } else {
            element = aStack.top();
            aStack.pop();
            pointer = element.pointer;
			
            if (element.tag == Tags::Left) { // 从左子树回来
	            // 标签设为Right并入栈
                element.tag = Tags::Right;
                aStack.push(element);
                // 移到右子树
                pointer = pointer->rightchild();
            } else { // 从右子树回来，访问当前结点
                Visit(pointer); 
                pointer = NULL; // 置pointer为空，以继续弹栈
            }
        }
    }
}
```

以下面这个树为例

![[数算/img/img5/image-4.png]]

从 A 开始一直往左下降，直到 D ，此时情况为
- `aStack: (A,L) (B,L) (D,L)`（左侧为栈底）
- 出栈序列：无
- 访问节点：无

在 D 处，左子树为空，弹出 `(D,L)` 压入 `(D,R)` ，发现其右子树也为空，弹出 `(D,R)` ，而后访问 D 
- `aStack: (A,L) (B,L)`
- 出栈序列：`(D,L) (D,R)`
- 访问节点：D

对于 B 的情况类似，访问完 B 后回到 A ，移到其右子树 C 并往左下降到 E 
- `aStack: (A,R) (C,L) (E,L)`
- 出栈序列：`(D,L) (D,R) (B,L) (B,R) (A,L)`
- 访问节点：D B 

发现 E 无左子树，访问右子树 G ，而后回退到 C ，访问其右子树 F 
- `aStack: (A,R) (C,R) (F,L)`
- 出栈序列：`(D,L) (D,R) (B,L) (B,R) (A,L) (E,L) (G,L) (G,R) (E,R) (C,L)`
- 访问节点：D B G E

后续同理，最后可得访问节点的顺序为 D B G E H I F C A

---

在各种遍历中，每个节点都被访问 1 次，对于前序和中序，每个节点出栈入栈 1 次；对于后序，每个节点分别从左/右出栈入栈 1 次，时间复杂度 $O(n)$

对于深搜，栈的深度与树的高度有关，时间复杂度为 $\Omega(\text{log}n)$ 和 $O(n)$

## BFS

对于广搜，只需将栈换为队列

```cpp
void BinaryTree<T>::LevelOrder(BinaryTreeNode<T>* root) {
    using std::queue;
    queue<BinaryTreeNode<T>*> aQueue;
    BinaryTreeNode<T>* pointer = root;
    if (pointer) aQueue.push(pointer);

    while (!aQueue.empty()) {
        pointer = aQueue.pop();
        Visit(pointer->value());
        if (pointer->leftchild())
            aQueue.push(pointer->leftchild());
        if (pointer->rightchild())
            aQueue.push(pointer->rightchild());
    }
}
```

# 存储结构

## 动态存储

采用链式方式存储，每个节点存储在内存的随机位置中，通过指针关联
- 二叉链表：存左和右子树的指针，以及自身信息
- 三叉链表：存左右子树和父节点的指针，以及自身信息

在删除时，可以从根节点开始递归的删除子树

## 静态存储

由于二叉树是非线性的，但是静态存储是线性的，必须能根据一个线性序列恢复出二叉树结构，而完全二叉树就满足要求，对其从上到下、从左到右的进行编号即可

![[数算/img/img5/image-5.png]]

完全二叉树中除最下面一层外，各层都是满的，每一层节点个数是上一层节点个数的 2 倍，因此根据一个节点的编号就可以推知它的父子节点的编号
- 当 $2i+1 < n$ 时，节点 $i$ 的左子节点是 $2i+1$，否则没左子节点
- 当 $2i+2 < n$ 时，节点 $i$ 的右子节点是 $2i+2$，否则没右子节点
- 当 $0 < i < n$ 时，节点 $i$ 的父节点是 $\lfloor (i-1)/2 \rfloor$
- 当 $i$ 为偶数且 $0 < i < n$ 时，节点 $i$ 的左兄弟是 $i-1$，否则没有
- 当 $i$ 为奇数且 $i+1 < n$ 时，结点 $i$ 的右兄弟是 $i+1$，否则没有

对于非完全二叉树，可以先补充一堆空节点使其成为完全二叉树，然后依次存储

![[数算/img/img5/image-6.png]]

# 二叉搜索树 BST

二叉搜索树（二叉排序树）满足以下性质
- 对于任意节点，左子树中的节点值比它小，右子树比它大
- 左右子树也是二叉搜索树
- 节点值唯一

按照中序遍历将节点值输出，得到的结果就是由小到大的排列

当查找一个数时，只需将其与根节点比较，如果小于则在左子树找，如果大于则在右子树找，递归的进行下去，如果碰到叶节点仍不相等，则不含这个数

插入过程与查找类似，直到碰到一个叶节点，与其比较，决定放到其左分支还是右分支

---

在查找和插入时，由于只需要访问左右子树中的一个，所以效率很高，但是其前提是这个 BST 是比较平衡的，即节点在左右子树的分布比较均匀

在构建 BST 时，如果顺序的按照输入序列进行构建，无法保证其平衡性，当输入序列的排序比较随机的时候，效果会更好

![[数算/img/img5/image-7.png]]

---

要删除 BST 的一个节点，需要保证删除后仍然是一个 BST ，如果这个节点没有左子树，那直接把其右子树接上来就行；如果同时有左右子树，一个简单的想法是直接把左子树接上来，此时右子树断开了，把它连接到左子树中的最大节点（由于是最大的，所以其没有右子树）

比如对于下面这个 BST ，删除 35 和删除 40 对应的结果分别如下

```
.       50                   50                   50
.      /  \                 /  \                 /  \
.     30   70              30   70              30   70
.    /  \    \            /  \    \            /  \    \
.   20   40   80         20   40   80         20   35   80
.  /    /  \    \       /    /  \    \       /       \    \
. 10   35  45    90    10   38  45   90    10        38    90
.       \   \               /    \                   / \
.       38  46             36    46                 36 45
.       /    \                    \                     \
.      36    47                   47                    46
.                                                        \
.                                                        47
.
.                           [delete 35]          [delete 40]
```

但是这很容易造成不平衡，这是因为我们直接移动了整个的右子树，把它接到别的地方，如果右子树本身就比较长，连接的地方又靠下，那就会显得很累赘

所以考虑不移动右子树，而是把左子树的最大节点移到被删除的节点进行替换，此时这个最大节点的左子树断开了（其没有右子树），直接接上来就行

```
.       50                   50
.      /  \                 /  \
.     30   70              30   70
.    /  \    \            /  \    \
.   20   40   80         20   38   80
.  /    /  \    \       /    /  \    \
. 10   35  45    90    10   35  45   90
.       \                   /    \
.       38                 36    46
.       /                         \
.      36                         47
.
.                          [delete 40]
```




































