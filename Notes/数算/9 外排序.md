
# 计算机存储器

- 主存储器（简称“内存”或“主存”）
	- 随机访问存储器 Random Access Memory, RAM
	- 高速缓存、视频存储器等
- 外存储器（简称“外存”） 
	- 硬盘、软盘、磁带等
	- 容量很大，但读写较慢

## 内存

RAM ：通常被封装在芯片中，基本存储单元是一个 cell （储存 1bit 数据），多个 RAM 芯片组成一个内存系统，分为 SRAM 和 DRAM 
- SRAM (Static RAM) 
	- 静态存储器，不需要定时刷新
	- 访问速度快，但制造成本高，容量相对较小
	- 用作计算机缓存 cache memories ，分为一级/二级/三级缓存
- DRAM (Dynamic RAM) 
	- 需要周期性刷新存储的数据，否则数据会丢失
	- 访问速度慢，但制造成本低，容量相对较大
	- 用于计算机主存 main memories 和帧缓冲器 frame buffers

整了这么多种存储器，它们的关系可以参考下图，一些高频使用的东西被存储到访问速度更快的地方，能大大节省时间

![[数算/img/img9/image.png]]

---

下图是一个简单的 CPU 与内存进行数据交流的通道，通过总线 bus 连接

![[数算/img/img9/image-1.png]]

- CPU chip
    - Register 寄存器：CPU内部的一小块超高速的存储空间
    - ALU (Arithmetic and Logic Unit) 算术逻辑单元：执行计算的核心
    - Bus interface ：CPU与其他硬件（如内存）通信的接口，用于数据的传输
- I/O bridge 输入/输出桥连接设备：协调外围设备和内存之间的数据交换

## 外存

传统的外存是 HDD 机械硬盘，类似于一个唱片机，用磁头在盘片上面读写数据

![[数算/img/img9/image-2.png]]

- Platters 盘片：表面有磁性材料，通过磁性的变化来存储数据
- Spindle 主轴：盘片绕着这玩意转
- Arm 磁头臂：连接磁头，把磁头移动到需要的位置
- Actuator 驱动器：控制磁头臂移动
- SCSI Connector ：硬盘与外部设备连接的接口

一个硬盘有很多盘片，每个盘片分为正反两面，都能存数据；其中的每个表面上有一堆圆环形的磁道 track ，每个磁道又由很多扇形的扇区 sector 组成，扇区之间会有一定的间隙 gap ；总容量就是把这一堆东西的数量/容量都乘起来

![[数算/img/img9/image-3.png]]

以读取为例，假设要读取蓝色扇区的数据，又已知盘片是逆时针转的，我们先把磁头放到起始的地方，这样随着盘片的旋转，这个区域的数据就被读取了

![[数算/img/img9/image-4.png]]

但是很多时候磁头并不是一开始就恰好处于扇区的起始位置，需要先调整到对应的磁道，再等对应的扇区转过来才能开始读，比如读完了前面的蓝色扇区，现在要读红色扇区，就需要这么做

![[数算/img/img9/image-5.png]]

可见中间需要经历数据传输、调整磁道、等待旋转的延迟

SSD 采用不同的原理，不需要像这样物理的进行移动，访问速度比 HDD 快，但还是比内存慢

整个的存储层次如下

![[数算/img/img9/image-6.png]]

外存的存储与访问特点
- 被划分为长度固定的存储空间
- 访问时分为定位和存取两个阶段
- 访问以块 Block 为单位进行，从而减少定位次数，进而减少时间耗费

# 外排序

要排序的东西太多了，内存一次性读不下，只能分成若干段来读取并排序，这部分排序好的段叫做**顺串/归并段**，顺串写回外存，让内存空间用于处理其它部分，等到原始序列的东西都搞成顺串后，把它们归并起来，总结起来就是下面两个过程
- 置换选择排序：把输入的外存序列搞成一堆顺串，尽可能让顺串总数较少，每个顺串较长，这样后续归并时能少弄几次
- 归并：把所有顺串重新组织成一个排好序的序列

由于涉及到外存，所以数据的读写时间也要考虑进来，要让读写次数尽可能少

>在外排序与后面的检索中，对于涉及外存的情况，实际上是把所有记录存到一个文件里，对一个文件内的很多记录排序，而不是对多个文件进行排序；对于外存，可以给每个记录设置一个 offset 代表其位置，表示相对于文件开头偏移了多少

## 置换选择排序

假设要从小到大排序，借助最小堆
- 先读取一段序列到内存中，构建成最小堆
- 从最小堆弹出堆顶元素，写入到一个临时文件（缓冲区）中，暂时储存顺串
- 从输入文件读取序列中下一个元素，与刚才弹出的元素比较
	- 如果比弹出元素小，我们就不能把它写入到这个临时文件里，不然会破坏从小到大的顺序，也就是说不能放到最小堆里，得把它放到内存中别的地方
	- 如果大于等于弹出元素，就可以放到最小堆里
- 重复上述过程，直到最小堆空了，就搞一个新的最小堆生成新的顺串

---

假设一开始读取的这段序列长度为 $M$ ，即一开始构建的最小堆大小为 $M$ ，假设数据均匀分布，则每次读入新元素时，比弹出元素小的概率为 $\frac{1}{2}$ ，可以证明最后输出的顺串长度期望为 $2M$ 

证明：设当前堆中有 $S$ 个元素时，后续的输出次数为 $F(S)$ （显而易见，后续输出次数只与当前堆中元素个数 $S$ 有关，因为每次读入时事件概率都一样）

假设当前堆中有 $S$ 个元素，弹出一个元素后，有 $\frac{1}{2}$ 概率输入一个小于的元素，则堆大小变为 $S-1$ ，此时后续输出次数期望为 $F(S-1)$ ；有 $\frac{1}{2}$ 概率输入一个大于等于的元素，堆大小不变，此时后续输出次数期望为 $F(S)$ ，可得以下状态转移方程

$$F(S)=1+\frac{1}{2}F(S)+\frac{1}{2}F(S-1)$$

整理可得

$$F(S)=2S$$

而起始时堆里有 $M$ 个元素，故输出次数期望为 $2M$ ，即顺串长度的期望

---

代码实现时，可以用一个数组记录读入的元素，维护一个标记位 `last` ，表示数组中从开头到哪为止属于最小堆中的元素
- 如果弹出后读入大于等于的元素，直接放到弹出元素的位置，不用改 `last` 
- 如果弹出后读入小于的元素，先把 `last` 的元素放到弹出元素的位置，再把读入元素放到 `last` 位置，而后 `last -= 1` 把读入的元素排除在最小堆外

## 归并

假设有 $m$ 个顺串，把归并过程表示成一个树，假设每次归并只把 2 个顺串合并成 1 个，则树高为 $\lceil \log_2 m\rceil+1$ ，共进行 $\lceil \log_2 m\rceil$ 次归并

![[数算/img/img9/image-7.png]]

这个树结构是可以优化的，假如一些初始顺串比较长，如果一开始就对它归并，那就会形成一个更长的顺串，后续归并时还需要读一遍这么长的串，所以考虑让长度较大的顺串靠后归并，让短的先归并

![[数算/img/img9/image-8.png]]

如果把顺串长度视为一个节点的权重，这就等价于构建 Huffman 树的问题，得到的结果称为**最佳归并树**

---

除了优化树结构，还可以考虑减少归并次数，可以减少初始顺串数 $m$ ，或增加一次归并处理的顺串数 $k$ ，前者取决于置换选择排序算法，考虑后者，即 $k$ 路归并的情况

如果像二路归并一样，每一次都从 $k$ 个顺串头部遍历找出最小元素并弹出，这太麻烦了，因为每次只有一个头部元素发生变化，剩下的很多比较都是重复的

考虑把比较选出最小元素的过程表示成树结构，每个父节点记录其子节点的比较结果，这样头部元素变化后，只需要调整树的一部分就能选出新的最小元素

### 赢者树

每个节点记录比较时”胜利“的元素的下标，即较小的元素

![[数算/img/img9/image-9.png]]

整个树的根节点就是最小元素，弹出这个元素后，`L[3]` 变为 11 ，只需沿着其到根节点的路径，从下往上调整，每次与其兄弟节点比较，而后更新其父节点

![[数算/img/img9/image-10.png]]

### 败者树

另一种有点反人类的想法是，每个节点记录比较时”失败“的元素的下标，把胜利的元素传递到父节点（可以用一个临时变量/函数参数），逐层往上走，最后在整个树的根节点上面再搞一个节点，记录最终胜利者的下标

![[数算/img/img9/image-11.png]]

在重构时，每次不需要与兄弟节点比较，而是直接与父节点比较即可（不需要查找兄弟节点，这可能是败者树唯一优化的地方了，并没有减少读取和比较次数）

![[数算/img/img9/image-12.png]]

---

假设用数组 `L[1...n]` 表示叶节点（各顺串的头部元素），用 `B[1...n-1]` 表示内部节点，由扩充二叉树的性质，可得对于 $n$ 路归并，有 $n$ 个叶节点、$n-1$ 个内部节点，共 $2n-1$ 个节点

![[数算/img/img9/image-13.png]]

![[数算/img/img9/image-14.png]]

### 效率分析

假设对 k 个顺串进行归并
- 原始方法：找到每一个最小值的时间是 $O(k)$，产生一个大小为 n 的顺串的总时间是 $O(k \cdot n)$
- 败者树：初始化包含 k 个选手的败者树需要 $O(k)$ 的时间，读入一个新值并重构的时间为 $O(\log k)$ ，故产生大小为 n 的顺串的总时间为 $Θ(k + n \cdot \log k)$

访问外存次数分析（每次读取、写入均算作访问外存）
- 置换选择排序时，对于 $n$ 个记录，需要 $2n$ 次访外
- 归并时，如果进行了 $m$ 趟归并，需要 $m\cdot (2n)$ 次访外（其中 $m=\log_k R$ ，$k$ 代表 $k$ 路归并，$R$ 为初始顺串数）

赢者 / 败者树与堆的对比
- 使用堆选出最小元素进行归并
	- 优点：实现简单，空间代价更低（只需存储 k 个头部元素）
	- 缺点：每次调整堆时耗时更长（因为需要整体调整，没有充分利用之前的比较信息）
- 赢者 / 败者树
	- 优点：虽然没有减少访问外存的次数，也没有减少时间复杂度的量级，但是内存中的比较次数更少
	- 缺点：除了要存头部元素，还要存内部节点，空间开销更大






