
# 多维数组

数组：元素数量和元素类型固定的有序序列
- 静态数组：必须在定义时指定大小和类型
- 动态数组：可以在程序运行时才分配空间

多维数组：`ELEM[c1...d1]...[cn...dn]` 其中 $c_i$ 和 $d_i$ 是第 $i$ 个下标的下界和上界，可得总元素数量为 $\prod_i (d_i-c_i+1)$ 

存储方式：由于内存是一维的，所以需要把高维展平
- 行优先：先排右边的下标
- 列优先：先排左边的下标

计算一个元素的地址的基本思路是：某元素的地址 = 数组起始地址 + 该元素前面有几个元素 × 每个元素占多少地方

设各下标下界都是 0 ，一个元素长度为 $d$ ，对于二维数组 $A_{m\times n}$ ，$a_{ij}$ 的地址为

$$\text{LOC}(a_{ij})=\text{LOC}(a_{00})+(in+j)\cdot d$$

三维数组 $A_{m\times n\times p}$ ，$a_{ijk}$ 的地址为

$$\text{LOC}(a_{ijk})=\text{LOC}(a_{000})+(inp+jp+k)\cdot d$$

## 特殊矩阵

如果矩阵中的元素是有一定规律的，就不需要把每个位置的元素都存下来，而是只存“有用”的元素，把二维压缩成一维
- 对称阵：只存上 / 下三角部分
- 上 / 下三角阵：只存非 0 元素（即上 / 下三角部分，如果其余位置不是 0 ，而是同一个别的数 $w$ ，也可以这么做，此时可以把 $w$ 存到最后面）
- 稀疏矩阵：只存非 0 元素

要确定某个元素在一维数组中的哪个位置，只需要计算前面有多少个元素即可

![[数算/img/img12/image.png]]

![[数算/img/img12/image-1.png]]

对于稀疏矩阵，比较特殊，因为非 0 元素出现的位置是没有规律的，所以还要额外记录其位置，有下面几种方法
- 顺序存储：三元组表
- 链式存储：十字链表（沿着行 / 列指针一直往下走，即可访问该行 / 列的所有非 0 元素）
- 压缩表示 CSR ：采用压缩的行索引，第 $k$ 个元素代表矩阵第 $k$ 行的第一个非 0 元素在 value array 的哪个位置（其列号也可以据此找到）

![[数算/img/img12/image-2.png]]

![[数算/img/img12/image-3.png]]

![[数算/img/img12/image-4.png]]

## 矩阵乘法的时间代价

设 $A_{m\times p},B_{p\times n}$ ，则计算结果为 $C_{m\times n}$ 
- 采用正常存储方式，由于串行计算需要依次计算输出中的每个元素，时间复杂度为 $O(mpn)$ 
- 对于稀疏矩阵，设 $A$ 每行最多有 $t_a$ 个非 0 元素，$B$ 每列最多有 $t_b$ 个非 0 元素，则时间复杂度为 $O(m(t_a+t_b)n)$ 

![[数算/img/img12/image-5.png]]

# 广义表

广义表：线性表里每个元素必须是一个单蹦的东西，但是广义表里一个元素还可以是一个表（也可以是多层嵌套的表，即广义表）
- 单蹦的元素称为原子 atom ，是一个广义表的元素称为子表 sublist
- 广义表深度：嵌套了几层表（即括号层数）
- 表头：第一个元素 $x_0$ 
- 表尾：扔掉表头的表 $(x_1,\cdots,x_n)$ 

## 分类

分为线性表、纯表、再入表（可重入表）、递归表（循环表），可以用树 / 图结构来表示，重复的原子 / 子表就直接指过去

![[数算/img/img12/image-6.png]]

![[数算/img/img12/image-7.png]]

![[数算/img/img12/image-8.png]]

![[数算/img/img12/image-9.png]]

## ADT

由于广义表存在嵌套结构，用顺序表存储会很别扭，而且广义表本身就可以表示成树 / 图的形式，所以考虑链式存储

```cpp
// 元素类型标签，ATOM = 0：单元素；LIST = 1：子表
typedef enum {ATOM, LIST} TAG;
// 广义表的节点
typedef struct GLNode{
    TAG tag; // 元素类型
    union {
        ElemType data; // 一个类型为ElemType的原子
        GLNode* sublist; // 子表
    };
    GLNode* next; // 指向下一元素
};
```

其中 `union` 是一种类似于 `struct` 的东西，但是含义不同
- 一个 `union` 中，同一时刻只会存储一个成员的值，如果要存储另一个成员的值，会直接覆盖掉原先存的东西
- 所有成员共用同一块内存，内存大小由最大成员的大小决定，确保不管存谁都能存得下
- 这非常适用于广义表这种情况，因为一个元素要么是一个原子，要么是一个表，所以只用存其中一种即可

## 存储

值得注意的是，这里我们会给每一个子表都搞一个专属的头节点，且将其标记设置为 `tag = -1` ，如果不这么做，在删除元素时会很难办

比如说 `A = ( L1:(2, 3), L2:(L1, 5) )` ，想要删除 L1 中的第一个元素 2 
- 没有头节点：那 L2 中的第一个元素（指向 L1 的指针，由于没有头节点，所以直接指向其第一个元素）就会变成悬空指针，还得调整，太麻烦了
- 有头节点：L2 的第一个元素指向 L1 的头节点，所以删了 L1 的第一个元素，仍能正常访问剩余元素

此外，还可以给每个子表搞一个 `refcount` ，记录被其它地方引用的次数，如果 `refcount` 是 0 ，那么在删除这个子表时，就毫无顾虑了；但如果要删除一个被其它地方引用的子表，就还得调整其他节点

---

一个潜在的问题是：对于 `(L1:(a,b),L2:(a))` 这种表，如果 L2 中的 a 位置直接指向 L1 中的 a ，那就乱套了（因为 L1 和 L2 中，a 的后继情况是不同的）

所以我们规定，只有两个表完全一样，才能指过去（指到表头），其余情况需要重复存储

但实际上，还可以采用另一种存储方式（见 [广义表的存储结构详解（包含2种存储方案）](https://c.biancheng.net/view/3380.html) 中的第一种方案），这样就不用担心上述情况了（见 [如何画出广义表的存储结构](https://blog.csdn.net/qq_46500711/article/details/126501497) ）

# 可利用空间表

内存管理最基本的问题就是分配存储空间、回收被释放的存储空间，可以把存储器中的空闲块链接起来，形成可利用空间表 freelist 
- 使用 `new` 时，从空闲块中分配一个出去，相当于链表中删除节点，可以选择删除表头节点
- 使用 `deleta` 时，把释放的地方连接到空闲表里，相当于链表中插入节点，可以选择插入到表头

![[数算/img/img12/image-10.png]]

但是上面的操作都是针对于单位长度的内存块，如果要申请一片连续的内存，就需要判断空闲表里有没有这样一个地方，这里我们把一片连续的空闲块 / 占用块视为一个整体，且往往使用双链表结构来构建空闲表
- 分配：找到长度大于等于申请长度的空闲块，截取一段出来
- 回收：需要考虑释放的一片空间能不能与相邻空间合并，形成一个长度更大的空闲块

![[数算/img/img12/image-11.png]]

## 分配

在分配时，如果申请的长度小于空闲块的长度，有下面两种选择
- 把整个空闲块都分配出去，那在已分配的内存中，会存在一些未使用的部分，称为“内部碎片”
- 只分配实际需要的长度，那这就会剩下一个更短的空闲块，多次分配后，会出现一堆零散的短块，称为“外部碎片”

无论发生哪种情况，都会导致明明内存中有可用的部分，而且总长度可能是够的，但就是无法分配出去（要么标记为已分配，要么不连续）

空闲块的顺序适配
- 首先适配 first fit ：找到第一个满足要求的空闲块就分配
	- 分配速度快，碎片会集中在空闲表前端
- 最佳适配 best fit ：找到满足要求的最小空闲块分配
	- 减少空间浪费，但是会留下一堆很小的碎片
- 最差适配 worst fit ：找到最大的空闲块分配
	- 避免产生太小的空闲块，但是会消耗大块内存，不利于后续的大片申请
	- 比如先后申请的长度为 20 和 90 ，有长度为 30 和 100 的空闲块，如果用最差适配，分配 20 后，长度 100 的空闲块就变成 80 ，那就没法分配给 90 了

实际系统常使用首先适配的变种以提高效率

## 回收

回收时，考虑将回收部分 M 与相邻的空闲块 L 和 R 合并（对于两个相邻空闲节点，去掉右边的节点，然后将左边的长度增加）
- 检查 M 的左邻 L ，如果空闲，就将 L 的长度增加 M 
- 否则把 M 放入空闲表
- 而后检查右邻 R ，如果空闲，就把 R 删除，并将 L / M 的长度（取决于前面 L 是否空闲）增加 R 

## 失败处理策略

前面提到：明明内存中有可用的部分，而且总长度可能是够的，但就是无法分配出去，此时存储管理器可能有两种行为
- 直接返回申请失败
- 采用失败处理策略 failure policy ，把能用的地方再拼一拼

![[数算/img/img12/image-12.png]]

无用单元收集：最彻底的 failure policy 
- 普查内存，标记出不属于任何链的节点
- 把它们收集到空闲表中
- 回收时通常与内存压缩一起进行

# Trie 树

Trie 树（字典树，前缀树）主要用于字符串检索、前缀匹配
- 根节点不包含字符，其余节点均包含一个字符
- 从根节点到一个节点的路径上经过的字符连起来，就是这个节点对应的字符
- 一个节点的所有子节点包含的字符互不相同

分类
- 二叉 Trie 树：用于表示二进制数字，每个节点的字符是 0 / 1
- 26 叉 Tire 树：用于表示英文单词，每个节点是一个字母

![[数算/img/img12/image-13.png]]

在 trie 树中查找一个关键字的时间和树中包含的节点数无关，而与关键字的长度有关，如果长度不是很大，在 trie 树查找要比在 BST 查找快

>比如关键字长度最大是 5，那就可能有 $26^5$ 种关键码，对于 trie 树，5 次比较即可找到；而对于 BST ，至少要 $\log_2 26^5 = 23.5$ 次比较

Trie 字符树是不平衡的
- 一些子树的分支可能非常多（比如 t 开头的单词比 z 开头的多很多）
- 每个节点有 26 个分支，树结构太大了

## Patricia 树

Patricia 树（PAT-tree，压缩前缀树）是 trie 树的一种改进版本，将单一路径上的节点进行压缩，每个节点不一定只存一个字符

![[数算/img/img12/image-14.png]]

## 后缀树

后缀树是给定字符串的所有后缀组成的压缩 Trie 树，这里给每个后缀的后面都加上一个 `$` 代表串尾，以进行区分（比如一个后缀可能是另一个后缀的子串）

![[数算/img/img12/image-15.png]]

比如 `banana` 的后缀为 `banana$` `anana$` `nana$` `ana$` `na$` `a$` `$` ，构建的 suffix trie 就长这样，可用于解决图中这些问题

![[数算/img/img12/image-16.png]]

>图中每个叶节点都有一个数字，代表这个后缀的起始位置

判断模式串是不是子串
- 从根节点开始逐层往下访问，如果能连续的访问到，就是子串
- 如果中间哪一步在子节点中没有找到对应的字符，就不是子串
- 这是因为，如果一个模式串出现在字符串中，它一定是某个后缀（从 P 的开头到字符串结尾）的前缀，那就对应着从根节点到某个节点的路径

>比如找 `P="ana"` ，先在根节点的子节点中找 `a` ，再在 `a` 的子节点找 `n` ，依此类推

判断模式串是不是后缀：先在末尾加上 `$` ，而后从根节点开始往下走到叶节点

判断模式串的出现位置及次数
- 从根节点出发，取最后一个匹配的节点，看其子树有多少个叶节点，就代表出现了多少次；出现位置就是这些叶节点对应的数字
- 这是因为，如果一个模式串 P 出现在字符串中，它一定是某个后缀的前缀，而且这些后缀都有共同的前缀 P ；而后缀树是 trie 树，一个节点的子树就代表有共同前缀的子串
- 时间复杂度为 $O(l+k)$ ，$l$ 为 P 的长度，$k$ 为出现次数

![[数算/img/img12/image-17.png]]

找到最长重复子串
- 找到最深的分叉节点
- 这是因为，一个分叉节点就代表有多个具有共同前缀的后缀，也就意味着一个子串多次出现，而深度就是这个共同前缀的长度

![[数算/img/img12/image-18.png]]

此外，后缀树还能用于找两个字符串 X 和 Y 的公共子串
- 把它俩拼成一个字符串 `X#Y` ，构建其后缀树
- 对每个叶子节点进行标记，表示它的开头在 X 还是在 Y 
- 找到一条路径，其最后一个节点对应的子树的叶子节点，既有 X ，也有 Y 
- 这条路径对应的字符串就是公共子串

![[image-30.png]]

>图中省略了以 `#` 开头的后缀，因为 X 和 Y 不包含 `#` ，那公共子串就也不含 `#` ，所以符合要求的路径的开头不可能是 `#` ；实际上完全不需要添加 `#` ，因为我们只需确定每个叶子节点的开头在 X 还是在 Y 就行，这通过 X 和 Y 的长度就能判断（比如 X 长度为 3 ，那 0 1 2 就在 X 里，后面的就在 Y 里）

---

后缀树的另一种压缩存储方式：对于一段路径代表的字符串，用 $(\text{offset},\text{length})$ 代替，其中 offset 为这个子串开始的位置，length 为其长度

![[image-31.png]]

# BST 的扩展

## 最佳 BST

### 问题设定

想让总查找代价最小，咋衡量查找代价呢？设 BST 中的关键码为 $K_1<\cdots<K_n$ ，查找 $K_i$ 的频率为 $p_i$ ；但是还可能查找这些关键码之外的数，设查找的关键码处在 $(K_i,K_{i+1})$ 内的频率为 $q_i$ ，其中 $i=0,1,\cdots,n$ ，对应这 $n$ 个关键码划分出的 $n+1$ 个区间

我们把 BST 进行扩充，扩充出的外部节点表示在对应区间内，但不是关键码的数，对应上述查找失败的情况（由扩充二叉树性质可知，外部节点有 $n+1$ 个，正好对应上述 $n+1$ 个区间）

设 $K_i$ 所在层数为 $I_i$ （从 0 开始），第 $i$ 个外部节点的层数为 $I_i'$ ，则查找时的平均比较次数为

$$ASL(n)=\frac{1}{W}(\sum_{i=1}^np_i(I_i+1)+\sum_{i=0}^nq_iI_i')$$

其中 $W=\sum_{i=1}^n p_i+\sum_{i=0}^n q_i$ 

>当所有概率均相等时，$\sum_{i=1}^nI_i$ 即为内部路径长度和 $I$ ，$\sum_{i=0}^nI_i'$ 是外部路径长度和 $E$ ，而 $E=I+2n$ ，故 $ASL(n)=\frac{2I+3n}{2n+1}$ 

问题就变成了，给定关键码 $K_1<\cdots<K_n$ 与权重 $p_1,\cdots,p_n,q_0,\cdots,q_n$ ，如何构建最佳 BST 使得 $ASL(n)$ 最小

### 构建

可以发现，最佳 BST 有个性质：任意子树都是最佳 BST （用反证法易证）
- 据此，可以考虑先构建只有 1 个节点的最佳 BST ，再构建 2 个节点的，逐渐增加节点数
- 这可以利用 dp 来解决

定义以下数组
- `r(i,j)` ：包含 $K_{i+1},\cdots,K_j$ 的最佳 BST 的的根节点
- `c(i,j)` ：包含 $K_{i+1},\cdots,K_j$ 的最佳 BST 的查找代价
- `w(i,j)` ：$W(i,j)=(p_{i+1}+\cdots+p_j)+(q_i+\cdots+q_j)$

考虑状态转移方程，对于包含 $K_{i+1},\cdots,K_j$ 的最佳 BST ，设其根节点为 $K_r\ (i+1\leq r\leq j)$ ，则它的左右子树的关键码为 $K_{i+1},\cdots,K_{r-1}$ 和 $K_{r+1},\cdots,K_j$ ，那么它的查找代价就是

$$c_r(i,j)=c(i,r-1)+c(r,j)+W(i,j)$$

加上 $W(i,j)$ 这一项是因为左右子树中所有节点的深度都增加了 1 ，并加入了新的根节点 $K_r$ 

而最佳 BST 的查找代价就是所有情况中，代价最小的那个，即

$$c(i,j)=\min_{i+1\leq r\leq j}(c(i,r-1)+c(r,j))+W(i,j)$$

并把对应情况下的 $r$ 记录到 `r(i,j)` 中，即

$$r(i,j)=\arg\min_{i+1\leq r\leq j}(c(i,r-1)+c(r,j))$$

最后只需要递归的访问 `r(i,j)` ，即可从根节点开始逐渐往下构建出最佳 BST 
- 设 $r(i,j)=R$ ，则左右子树分别为 $K_{i+1},\cdots,K_{R-1}$ 和 $K_{R+1},\cdots,K_j$ 
- 左右子树的根节点就是 $r(i,R-1)$ 和 $r(R,j)$

## 平衡 BST (AVL)

最佳 BST 只解决了构建的问题，并没有解决插入和删除仍需保持平衡的问题，为此发明了 AVL ，它具有以下性质
- 一个 AVL 的左右子树也是 AVL ，且树高差距最多为 1 
- 一个有 $n$ 个节点的 AVL，高度为 $O(\log n)$ ，其 ASL 也是这个级别的

>后来又进行了扩展，高度差限制可以不是 1 ，这种情况下平均访问的节点数量增加了，但是在插入和删除后调整时进行的重组次数降低了

平衡因子
- 一个节点 $x$ 的平衡因子 = 其右子树高度 - 其左子树高度，记为 $bf(x)$ 
- 取值范围为 $\{0,1,-1\}$ 
- 左子树更高的情况称为“左重”，反之为“右重”

插入和删除时需要看的，就是有没有导致失衡（左右子树高度差距超过 1 ，即某个节点的平衡因子在取值范围之外，由于原来最大高度差距为 1 ，所以失衡情况下高度差距为 2 ，即平衡因子为 2 或 -2 ）

### 插入

与 BST 类似，先进行一次（失败的）查找，确定插入位置，如果导致失衡，需要进行平衡操作，有下面几种情况（其中 A 为失衡节点）
- LL 型：插入到 A 的左子树的左子树导致失衡，此时 $bf(A)=-2$ 
- LR 型：插入到 A 的左子树的右子树导致失衡，此时 $bf(A)=-2$ 
- RL 型：插入到 A 的右子树的左子树导致失衡，此时 $bf(A)=2$ 
- RR 型：插入到 A 的右子树的右子树导致失衡，此时 $bf(A)=2$ 

需要进行的调整操作如下，与红黑树中提到的操作相同
- LL 和 RR ：旋转
- LR 和 RL ：提升（双旋转）

![[数算/img/img12/image-19.png]]

![[数算/img/img12/image-20.png]]

![[数算/img/img12/image-21.png]]

### 删除

与 BST 类似，先与后继交换再删除，设删除位置的父节点为 root ，可能有以下情况

 - $bf(root)=0$ ：直接删了，并更新 $bf(root)$ 就行，不用向上检查，因为以 root 为根的子树高度没有改变，不会影响其祖先的 bf 

![[数算/img/img12/image-22.png]]

 - $bf(root)\neq0$ ，且较高的子树被缩短：删除后，以 root 为根的子树的高度减小，可能导致祖先节点失衡，需要向上检查（标记 `modified=true` ）

![[数算/img/img12/image-23.png]]

 - $bf(root)\neq0$ ，且较矮的子树被缩短：删除后需要调整，也可能需要向上检查，不妨设删除的节点在 root 的左子树（删除节点在右子树时，需要进行的调整是对称的），设 root 的右子节点为 right ，可能有以下情况
	- $bf(right)=0$ ：进行旋转，不用向上检查
	- $bf(right)=bf(root)$ ：进行旋转，需向上检查
	- $bf(right)\neq bf(root)$ ：进行提升，需向上检查

对于 $bf(root)\neq0$ 的情况，需要进行哪种调整，和插入时是类似的；而需不需要向上检查，只需判断调整后，以 root 为根的子树高度变没变，不用死记硬背

![[数算/img/img12/image-24.png]]

![[数算/img/img12/image-25.png]]

![[数算/img/img12/image-26.png]]

>Case 3.3.2 和 Case 3.3.3 分别是 2 和 3 号树的高度为 $h-2$ 和 $h-1$ ，以及均为 $h-1$ 的情况，进行的调整都是相同的，而且都需要向上检查

### 与红黑树的对比

- AVL ：完全平衡
- RB-Tree ：局部平衡，统计性能好于 AVL ，增删记录性能也更好

- 插入时引发不平衡：二者都最多只需 2 次旋转，都是 $O(1)$ 的
- 删除时引发不平衡：最坏情况下 AVL 需要一直往上检查，而 RB-Tree 最多只需 3 次旋转（但是可能有很多次变色，所以其实效率不会差太多）

- 由于 AVL 的要求更严格，插入和删除时更容易引发不平衡，需要的调整频率更高，所以对于大量插入和删除的场景， RB-Tree 效率更高
- 但是由于 AVL 是高度平衡的，所以查找效率更高

## 伸展树

数据访问的“二八规则”：80% 的人往往只会用到 20% 的数据，所以我们希望让频繁访问的数据放到更容易被检索到的位置

伸展树不是一个新的数据结构，只是对 BST 的一些改进规则，能让访问的总代价降低，但不能保证树高平衡

在查找、插入、删除时，伸展树会额外进行以下操作
- 查找 x 
	- 如果找到了 x ，通过伸展操作把 x 变到树根
	- 如果没找到，把查找路径上最后访问的节点伸展到树根
- 插入 x ：先按照 BST 的方法插入进去，而后通过伸展操作把 x 变到树根
- 删除 x ：先查找 x （这会让 x 伸展到树根），而后删除这个节点
	- 如果 x 变为树根后没有左 / 右子树，那就直接结束
	- 否则需要把左子树中的最大节点伸展到左子树的根部（由于是左子树中最大的，所以伸展后其没有右子树），并把 x 的右子树接上去

在伸展过程中，需要通过一系列旋转，把 x 往上移
- 单旋转：当 x 是树根的孩子时，进行单旋转往上移动 1 层，这就到了根节点
- 双旋转：其它情况下，进行双旋转，把 x 往上移动 2 层

其中单旋转和之前相同，双旋转分为一字型和之字形，之字形就是前面的提升操作，下面是一字型双旋转的过程

![[image-27.png]]

一字型和之字形的旋转会有一些结果上的差别
- 一字型：一般不会降低子树的高度
- 之字形：会让子树的高度 -1 ，让树结构趋于平衡

伸展树的效率
- 不能保证单次访问效率很高，仍为 $O(n)$ 
- 可以保证 m 次操作耗时 $O(m\log n)$ ，即平均效率较高，为 $O(\log n)$ 

可见伸展树的结构与每个节点的访问频率相关，更频繁访问的节点就会在更上层

### 基于伸展树的区间操作

区间提取：给定序列 $n_1,\cdots,n_m$ ，要找到处在 $[n_a,n_b]$ 中的数
- 根据序列构建伸展树
- 把 $n_a$ 的前驱转移到树根
- 把 $n_b$ 的后继转移到树根的右孩子
- 转移后 $n_b$ 的左子树即为相应区间，对其中序遍历，即可得到相应子序列

区间删除：先进行区间提取，然后删掉对应的子树

区间插入：在序列 A 中 $n_a$ 和 $n_{a+1}$ 之间插入序列 B 
- 根据序列 A 构建伸展树
- 把 $n_a$ 转移到树根
- 把 $n_{a+1}$ 转移到树根的右孩子（由于二者相邻，所以没有比 $n_{a}$ 大但是比 $n_{a+1}$ 小的数，此时 $n_{a+1}$ 没有左子节点）
- 把 B 构建成一个伸展树，作为 $n_{a+1}$ 的左子树

区间翻转：翻转一个序列中的 $[n_a,n_b]$ 的部分
- 先进行区间提取，找到对应区间的子树
- 对这个子树的每个节点，交换它的左右儿子，而后对整个树进行中序遍历即可得到翻转结果

### 半伸展树

在伸展树中，每次访问都得进行一大串调整，非常耗时，考虑对调整的过程进行优化或缩减，这有很多种方案，ppt 给了一种很神奇的伸展方式

对于原先的一字旋转，是直接把 x 移动到了最顶上，并继续对 x 进行操作；但现在我们是把 x 的父节点 y 移动到顶上，然后对 y 进行操作

![[image-28.png]]

整个过程如下（如果“当前节点”是树根的孩子，就和原来一样进行单旋转，把“当前节点”移到树根）

![[image-29.png]]









