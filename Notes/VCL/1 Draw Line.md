
讲义上只讲了布雷森汉姆的算法思路，并没有详细讲代码为啥要这么写；小测 1 中考了布雷森汉姆在各个方向的统一代码实现，故进行补充

此外附加题是椭圆的画法，可以参考 [各种曲线的Bresenham算法](http://members.chello.at/easyfilter/bresenham.html)

# Bresenham’s Line Algorithm

要绘制从 $(x_0,y_0)$ 到 $(x_1,y_1)$ 的直线，假设  和 $y_1>y_0$ ，如果把 $(x_0,y_0)$ 视为原点，就变成了考虑在第一象限画直线的情况，下简称“在第一象限内绘制”，其余象限同理

假设 $0<k<1$ ，已经绘制了 $(x,y)$ ，那下一步绘制时要么选 $(x+1,y)$ ，要么选 $(x+1,y+1)$ ，我们可以根据直线离哪个点更接近来进行选择

布雷森汉姆算法将上述想法表达为：当点 $(x+1, y+1/2)$ 位于直线的上方时，我们应该选择像素点 $(x+1, y)$，反之选择 $(x+1, y+1)$ 

![[VCL/img/img1/image.png]]

我们把直线用隐式方程表示，其中 $N$ 为经过 $P_0$ 的直线的法向量，$P$ 为直线上的任一点

$$N \cdot (P - P_0)=0$$

为了判断点在直线的哪一侧，可以将左侧定义为 $F$

$$F(P) := N \cdot (P - P_0)$$

- 当 $F < 0$ 时，$P$ 点位于直线上方，当 $F > 0$ 时位于直线下方，$F = 0$ 时点 $P$ 在直线上

可以发现其具有以下性质

$$
F(P + \Delta) = N \cdot (P + \Delta - P_0) = F(P) + N \cdot \Delta
$$

- 其中 $\Delta$ 为一个偏移向量

定义 $\Delta_0=(1,\frac{1}{2})$ ，则 $(x+1,y+\frac{1}{2})=P+\Delta_0$ ，我们就需要判断下式的正负

$$F(P+\Delta_0)=F(P)+N\cdot \Delta_0\tag{1}$$

在判断完后，绘制下一个点，定义其偏移量为 $\Delta_1$ ，可见要么 $\Delta_1=(1,0)$ ，要么 $\Delta_1=(1,1)$ ，判断这个点之后往哪画时，即判断下式的正负

$$F(P+\Delta_1+\Delta_0)=F(P)+N\cdot \Delta_1+N\cdot \Delta_0\tag{2}$$

可以发现 $(1)$ 和 $(2)$ 式中都有一个公共项 $N\cdot \Delta_0$ ，这是一个定值；而每次绘制下一个点时，$F$ 的变化量是 $N\cdot \Delta_1$ ，这只有两种取值，这些值都是可以预先计算好的

此外，在一开始判断 $(x_0,y_0)$ 下一步往哪画时，有

$$F(P_0+\Delta_0)=F(P_0)+N\cdot \Delta_0=N\cdot \Delta_0$$

所以我们维护一个 $F$ ，将其初始值设为 $N\cdot \Delta_0$ ，每次绘制后将其变化 $N\cdot \Delta_1$ 

为了避免计算 $N\cdot \Delta_0$ 时出现浮点数，可以取 $N=(2(y_1-y_0),-2(x_1-x_0))$ ，综合以上过程，代码实现如下

```cpp
void draw_line(int x0, int y0, int x1, int y1) {
    int x, y = y0;
    int dx = 2 * (x1 - x0);
    int dy = 2 * (y1 - y0);
    int dydx = dy - dx;
    int F = dy - dx / 2;
    for (x = x0; x <= x1; x++) {
        draw_pixel(x, y);
        if (F < 0) 
            F += dy;
        else {
            y++; 
            F += dydx;
        }
    }
}
```

---

但是上述代码需要分 8 个情况进行讨论，每个情况都得调整一下，这太麻烦了，有没有更统一的方式呢？

我们仍假设 $x_1>x_0$ 和 $y_1>y_0$ ，但不对斜率进行限制，此时对于 $(x,y)$ ，下一步有三种选择 $(x+1,y)$ $(x,y+1)$ $(x+1,y+1)$ ，可以分别判断在 $x$ 和 $y$ 方向上要不要进行移动

考虑用两点式表示这个直线

$$(y-y_0)(x_1-x_0)-(x-x_0)(y_1-y_0)=0$$

则点 $(x,y)$ 到直线的距离 $d$ 为

$$d=\frac{|(y-y_0)(x_1-x_0)-(x-x_0)(y_1-y_0)|}{\sqrt{A^2+B^2}}$$

- 其中 $A$ 和 $B$ 是把直线转换成 $Ax+By+C=0$ 后的系数
- 记 $dx=x_1-x_0,\quad dy=y_1-y_0$ ，则 $A=-dy,\quad B=dx$

我们维护一个误差值 $err$ ，可见它实际上是点到直线的距离的一个倍数

$$err(x,y)=(y-y_0)dx-(x-x_0)dy$$

- 在第一象限内，$err>0$ 说明点在直线左上侧，$err<0$ 说明点在直线右下侧，$err=0$ 说明点正好处在直线上
- 在第一象限内，增加 $x$ 会使 $err$ 减小，增加 $y$ 会使 $err$ 增大

---

在判断 $(x,y)$ 时，我们使用点 $(x+1,y+1)$ 处的 $err$ 进行判断

从起点开始看，以 $y$ 方向要不要增加为例，这与之前的思路一致，等价于判断图中黄色线和蓝色线哪个更长（红色线为标准直线），可以把它们放缩到直线终点处，可以计算，此时放缩后的黄色部分就是 $err$ ，过程如下

我们考虑点 $(x,y)$ 到直线的竖直距离 $d_y$ ，记直线倾斜角为 $\theta$ ，点到直线的垂线距离为 $d$ ，则（这里取有向距离，即区分正负，不取绝对值）

$$d_y=\frac{d}{\text{cos}\theta},\quad \text{tan}\theta=\frac{dy}{dx},\quad d=\frac{err}{\sqrt{dx^2+dy^2}}$$

可得

$$err=dx\cdot d_y$$

右边的含义就是把竖直距离放缩 $dx$ 倍，这正好与图片关于黄色线段的放缩相对应，那么放缩后的黄色线段就是 $err$

判断时，如果 $dx-dy\leq dy$ 就增加 $y$ ，这个不等式与 $2err<=dx$ 是等价的

![[VCL/img/img1/image-1.png]]

对于中间的某个点，我们把直线平移过去（图中深灰色线），仍然与之前的想法一致，只不过变成了需要比较黄色+蓝色的长度与绿色线的长度，此时黄色+蓝色部分就是 $err$ ，可以列出以下方程

$$
\begin{align}
&已知&&黄+蓝=err\\
& &&蓝+绿=dy\\
& &&黄=dx-dy\\
&待判断\ &&黄+蓝\leq 绿
\end{align}
$$

可以解得待判断的不等式也是 $2err<=dx$

![[VCL/img/img1/image-2.png]]

对于判断是否增加 $x$ 的情况同理，只不过这时考察的是水平距离，可得判断条件为 $2err\geq -dy$

>以上参考 [优化的Bresenham算法](https://www.cnblogs.com/scarecrow-blog/p/11238454.html)

判断完了后需要进行移动，计算三种选择移动后的点的 $err$ 

$$
\begin{align}
err(x+1,y)=err(x,y)-dy\\
err(x,y+1)=err(x,y)+dx\\
err(x+1,y+1)=err(x,y)+dx-dy
\end{align}
$$

可见如果在 $x$ 方向移动，就把  减少 $dy$ ；如果在 $y$ 方向移动，就把 $err$ 增加 $dx$ （这也可以通过计算直线平移后图中 $err$ 线段长度的变化得到）

---

对于别的象限，都可以通过某种方式对称到第一象限，所以我们只需要维护第一象限的 $err$ ，而在绘制时根据象限决定 $x$ 和 $y$ 要增加还是减少即可（即绘制时，我们在第一象限打草稿，每一步先在第一象限判断并计算 $err$ ，再把选择绘制的像素对称到所需象限）

```cpp
void drawLine(int x0, int y0, int x1, int y1)
{
	int dx =  abs(x1-x0;
	int dy = abs(y1-y0);
	sx = x0<x1 ? 1 : -1;
	sy = y0<y1 ? 1 : -1;
	int err = dx-dy, e2; // e2 = 2*err
 
	for(;;){
		draw_pixel(x0,y0);
		if (x0==x1 && y0==y1) break;
		e2 = 2*err;
		if (e2 >= -dy) { 
		    err -= dy; 
			x0 += sx; 
		}
		if (e2 <= dx) { 
			err += dx; 
			y0 += sy; 
		}
	}
}
```













