
# Edge & Corner Detection

见 CV 导论 CV 1/2

# Blobs

**Blob（斑点）** 指的是图像中一个连通区域，这个区域内的某些属性（如亮度、颜色、纹理）是相对均匀的，并且与周围的区域明显不同

特征检测中，edge 在边缘是渐变的等情况下难以精确定位；corner 虽然可以精确定位，但其仅表示拐角，缺乏独特的局部特征，区分度低；而 blob 则兼具二者优点，既能像角点一样被精确稳定地定位（沿着各个方向图像强度都发生了剧烈变化），又因其包含丰富的内部结构信息而具有高区分度，因此被认为是用于图像匹配等任务的优质兴趣点 interest point

以一维情况为例，假设有一个鼓包，这就可以看作一个 blob ，两侧陡升/陡降的部分对应两个 edge 

![[CV/img/img3/image.png]]

取其中的一侧，比如陡升的一侧，与高斯核进行卷积，根据卷积的定义与对称性，可以得到如下的结果，这就是滤波的过程

![[CV/img/img3/image-1.png]]

进一步的，考虑与高斯核的一阶导卷积，这可以检测出边缘，从上面可以得到 

$$f*h'=f'*h$$

而 $f$ 的导数是一个单脉冲函数 $\delta(x-x_0)$ ，即在 $x_0$ 处存在一个取值无穷大的脉冲，可以得到卷积结果在 $x_0$ 处的取值为 $\frac{1}{\sqrt{2\pi}\sigma}$ ，为了让这个值与 $\sigma$ 无关，可以乘上 $\sigma$ 进行归一化

![[CV/img/img3/image-2.png]]

再进一步，与二阶导卷积，可以发现卷积结果在 $x_0 \pm \sigma$ 取得极值 $\frac{1}{\sqrt{2\pi}\sigma^2}e^{-\frac{1}{2}}$ ，乘以 $\sigma^2$ 进行归一化

![[CV/img/img3/image-4.png]]


对于陡升的一侧，与二阶导卷积的结果是一个先凸后凹的形状，类似的，陡降的一侧卷积结果是先凹后凸的，那么整个 blob 的卷积结果就如下图

![[CV/img/img3/image-3.png]]

可以发现，如果 blob 的宽度合适，卷积结果会是一个先凸后凹再凸（两波峰一波谷）的形状，这就代表当前宽度的高斯函数检测出了一个对应大小的 blob ，根据波峰与波谷的位置可以确定这个 blob 的中心和宽度，如果逐渐调整高斯函数的 $\sigma$ ，就可以检测出不同大小的 blob 

对于二维情况，可以在 x 和 y 方向上分别用二阶导卷积，而后我们把这俩加起来作为相应函数，这正好是拉普拉斯算子的表达式

![[CV/img/img3/image-5.png]]

总结一下，二维 blob 检测的过程如下，可见二维 blob 检测出的实际上是一个圆形区域

![[CV/img/img3/image-6.png]]

# SIFT Feature

SIFT 全称 **Scale-Invariant Feature Transform**，即尺度不变特征变换，用于检测图像的局部特征

## Blob Detection

blob 通过检测 NLoG 的极值获取，即使图像被放缩，仍可以通过调整高斯函数的 $\sigma$ 检测到，所以这是 scale-equivariant 的，如果再进行尺度归一化，就是 scale-invariant 的，此外，blob 还对旋转、遮挡和噪声鲁棒，这些性质使得 blob 很适合用于 SIFT feature 的检测（先检测 blob 找到一些值得关注的特征区域，再对其内部进行局部特征的提取）

在检测 blob 时，可以采用 DoG 来近似 NLoG ，通俗的来理解，就是对一张图片进行较小程度的模糊，再进行较大程度的模糊，把二者做差，差异明显的部分就是检测出的 blob 

![[CV/img/img3/image-7.png]]

为了检测出不同大小的 blob ，可以进行一系列程度的模糊，即应用一系列不同倍率的 $\sigma$ ，再对相邻项两两做差，但是当高斯核 $\sigma$ 很大时，直接与图像卷积效率很低，此时可以对图像进行降采样，而后应用一个较小的 $\sigma$ ，也能实现相同的效果（这是由于 blob 是尺度不变的，改变图像尺度也能检测出来），但计算量大大减小

为此，可以对于一个尺度的图像应用一系列 $\sigma$ 后，进行降采样，对降采样后的图像再应用这些 $\sigma$ ，以此类推，把每一个尺度层称为一个 octave

![[CV/img/img3/image-8.png]]

那 $\sigma$ 的倍率怎么选呢？选大了可能漏掉一些 blob ，选小了计算量又太大，这里用到了高斯函数的一个性质：两个高斯函数卷积结果仍然是一个高斯函数，其标准差就是这两个高斯函数的方差的平方和的平方根，即

$$G(\sigma_1)*G(\sigma_2)=G(\sqrt{\sigma_1^2+\sigma_2^2})$$

我们选取 $k=\sqrt2$ 作为倍率，这样在构建金字塔的每一级时，不需要分别计算与原图的卷积，只需要在上一级的基础上应用同样级别的高斯函数卷积即可，这提高了计算效率

![[CV/img/img3/image-9.png]]

而后，我们在每层 DoG 上检测极值点，进而检测出 blob ，为了进一步增强鲁棒性，每一层 DoG 中的像素不只和当前层的相邻像素比较，还要和上下相邻层的相邻像素比较（各个 octave 内独自进行），即在整个尺度空间 (x, y, σ) 中找到极值，而不仅仅是在固定尺度平面 (x, y) 中的极值

![[CV/img/img3/image-10.png]]

可以发现，DoG 检测到的 blob 在边缘处有很强的响应

![[CV/img/img3/image-11.png]]

## SIFT Descriptor

检测出 blob 后，计算 blob 内每个像素的梯度方向及其模长，把其模长累加到对应的方向区间内（离散化到 8 个方向），其中最大的就是这个 blob 的主方向

由于边缘处对于 blob 特征的贡献比较小，可以用一个高斯函数对整个 blob 内的像素的梯度模长进行加权，这也能防止 blob 偏移时由于边缘变化导致特征向量剧变

![[CV/img/img3/image-12.png]]

在描述这个 blob 的特征时，同样可以用直方图的方式，此时把 blob 划分为 4×4 的小区域（图以 2×2 为例）以进一步体现细节信息，每个小区域设置 8 个方向区间，把坐标轴的 x 轴与主方向对齐，而后计算调整后的每个像素的梯度方向及其模长，把其高斯加权后的模长累加到对应的方向区间内，最后得到 4×4×8 共 128 个模长和，将其排列成一个向量，而后归一化，就得到了这个 blob 的特征向量（也称描述子 descriptor ）

>在构建金字塔时，就可以预先计算梯度模长，而后计算 blob 特征时直接用就行，避免 blob 重叠部分的像素重复计算

由于边缘处对于 blob 特征的贡献比较小，可以用一个高斯函数对整个 blob 内的像素的梯度模长进行加权，这也能防止 blob 偏移时由于边缘变化导致特征向量剧变

由于对齐了主方向，就有了旋转不变性；由于对各方向梯度模长和组成的特征向量进行了归一化，对图片亮度也具有不变性

![[CV/img/img3/image-13.png]]

## SIFT Feature Matching

有了 SIFT feature ，就可以对两个图片进行特征点匹配，可以定义如下的计算公式来判断两个 SIFT 描述子的相似性

![[CV/img/img3/image-14.png]]

在匹配时，可以对于一个图的每个 SIFT 区域，找到另一个图中最相似的 SIFT 区域，尽管可能产生 outlier （匹配的太离谱了），但 SIFT 特征匹配具有很强的鲁棒性

![[CV/img/img3/image-15.png]]

# HOG

HOG 全称 **Histogram of Oriented Gradients** ，相比于 SIFT ，HOG 关注的是图像的全局特征，其过程如下
1. 计算梯度：把图像调整为 128×64 大小，计算每个像素的梯度大小和方向
2. 构建直方图：将图像划分为若干个 cell （一般大小为 8×8 像素），对每个单元内的所有像素，按其梯度方向进行直方图统计
3. 块内归一化：将相邻的多个 cell（一般为 2×2 个）组合成一个块，将块内所有 cell 的直方图连接起来，并进行向量归一化，以滑动窗口方式遍历整个图像
4. 组合特征向量：将所有块的归一化后直方图连接成一个长的、一维的 HOG 特征向量

![[CV/img/img3/image-16.png]]

HOG 与 SIFT 的对比
- HOG 不具备旋转不变性，且只适用于固定尺度
- SIFT 只在关键点计算特征，是稀疏的；HOG 对整个图计算特征，是密集的
- SIFT 主要用于特征点匹配，HOG 主要用于目标检测（如行人检测） 

在使用 HOG 进行目标检测时，可以用 HOG feature 训练一个二分类器（如 SVM ，给出图像的 HOG feature 与分类标签作为训练数据），而后利用一系列尺寸的滑窗对每个窗口的图像提取 HOG feature ，并用分类器进行检测

